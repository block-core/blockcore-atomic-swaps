@page "/createswap"
@using Blockcore.AtomicSwaps.Server.Controllers
@using Blockcore.Utilities
@using NBitcoin
@using NBitcoin.Crypto
@using Blockcore.AtomicSwaps.BlockcoreWallet
@using System.Text.Json
@using Blockcore.AtomicSwaps.BlockcoreWallet.Exceptions
@using Blockcore.AtomicSwaps.Client.Services

@inject HttpClient Http
@inject Storage storage;
@inject SwapsConfiguration SwapsConfiguration;
@inject NavigationManager NavigationManager;
@inject ILogger<CreateSwap> Logger;
@inject IBlockcoreWalletService WalletService
@inject IBlockchainApiService BlockchainApiService

<PageTitle>Create Swap</PageTitle>

<h1>Create Swap</h1>

<p>This component allow to create new swaps.</p>

<p class="alert-danger">@error</p>

@if (!hasWallet)
{
    <p>Not wallet found please install the wallet at blockcore.net</p>
}
else
{
    <div class="row g-3 align-items-center mb-2">
        <div class="col-2">
            <label for="SwapFrom" class="col-form-label">From</label>
        </div>
        <div class="col-4">
            <select class="form-select" @bind="SwapFrom" type="text">
                <option value="" selected disabled>Please select</option>
                @{
                    @foreach (var prp in NetworkList)
                    {
                        <option value="@prp">@prp</option>
                    }
                }
            </select>
        </div>
        <div class="col-auto">
            <span class="form-text">
                seller
            </span>
        </div>
    </div>

    <div class="row g-3 align-items-center mb-2 mt-2">
        <div class="col-2">
            <label for="Amount" class="col-form-label">Amount</label>
        </div>
        <div class="col-4">
            <input class="form-control" @bind="amountToSell"/>
        </div>
        <div class="col-auto">
            <span class="form-text">
                @SwapFrom
            </span>
        </div>
    </div>

    <hr/>

    <div class="row g-3 align-items-center mb-2">
        <div class="col-2">
            <label for="SwapTo" class="col-form-label">To</label>
        </div>
        <div class="col-4">
            <select class="form-select" @bind="SwapTo" type="text">
                <option value="" selected disabled>Please select</option>
                @{
                    @foreach (var prp in NetworkList)
                    {
                        <option value="@prp">@prp</option>
                    }
                }
            </select>
        </div>
        <div class="col-auto">
            <span class="form-text">
                Buyer
            </span>
        </div>
    </div>

    <div class="row g-3 align-items-center mb-5 mt-2">
        <div class="col-2">
            <label for="Amount" class="col-form-label">Amount</label>
        </div>
        <div class="col-4">
            <input class="form-control" @bind="amountToBuy"/>
        </div>
        <div class="col-auto">
            <span class="form-text">
                @SwapTo
            </span>
        </div>
    </div>


    <button class="btn btn-primary" @onclick="CreateNewSwap">Create Swap</button>
}



@code {
	private List<SwapSession> swaps;
	Networks.Network network;
	List<string> NetworkList;

	string error;

	string SwapFrom = "STRAX";
	string SwapTo = "CITY";

	long amountToSell = 1;
	long amountToBuy = 2;
    private bool hasWallet;

    WalletAccounts? _walletAccounts;

	protected override async Task OnInitializedAsync()
	{
	    if (await WalletService.HasBlockcoreWallet() == false)
	    {
	        hasWallet = false;
	        return;
	    }

	    hasWallet = true;

	    NetworkList = SwapsConfiguration.Networks.Keys.ToList();

	    _walletAccounts = storage.GetOrCreate<WalletAccounts>();
	}

	protected async Task CreateNewSwap()
	{
	    ExtKey.UseBCForHMACSHA512 = true;
	    NBitcoin.Crypto.Hashes.UseBCForHMACSHA512 = true;

		// check that the user has enough money
		error = string.Empty;
	    if (SwapFrom == SwapTo)
	    {
	        error = "Cant swap to the same network"; 
	        return;
	    }

		Networks.Network network = SwapsConfiguration.Networks[SwapFrom];

	    var sessionId = Guid.NewGuid().ToString("N");

	    //var account = _walletAccounts.Account[SwapFrom];

        var (errorOut, account, sharedSecret, sharedSecretHash) = await ConnectWallet(sessionId);

	    if (!string.IsNullOrEmpty(error))
	    {
            error = errorOut;
	        return;
	    }

	    if (account.CoinSymbol != SwapFrom)
	    {
            error = $"Incorrect network selected, expected {account.CoinSymbol} selected {SwapFrom}";
	        return;
	    }

	    var amountToSellSats = Money.Coins(amountToSell);
	    var amountToBuySats = Money.Coins(amountToBuy);
		var totalBalance = Money.Satoshis(account.Balance);

		//if (totalBalance < amountToSellSats)
		//{
		//	error = "You do not have enough funds";
		//	return;
		//}

		var myswaps = storage.GetSwaps();

		if (myswaps == null)
		{
			myswaps = new List<SwapSession>();
			storage.SetSwaps(myswaps);
		}

	    var pubkey = account.Pubkey;

		var totalBalanceInSwaps = myswaps.Sum(s =>
		{
            if(s.CoinSeller.SenderPubkey == pubkey)
                return s.CoinSeller.Amount ;

            if (s.CoinBuyer.SenderPubkey == pubkey)
                return s.CoinBuyer.Amount;

            return 0;
		});

	    var totalBalanceInSwapsSats = Money.Satoshis(totalBalanceInSwaps);

		Logger.LogInformation($"accountInfo.TotalBalance={account.Balance} - totalBalanceInSwaps={totalBalanceInSwaps} - amountToSell={amountToSellSats}");

		//if (totalBalance - totalBalanceInSwapsSats < amountToSellSats)
		//{
		//	error = "funds are used in other swaps no funds left to make a swap";
		//	return;
		//}

	    var postBody = new CreateSwapSession
	    {
	        SenderPubkey = pubkey,
	        FromCoinSymbol = SwapFrom,
	        AmountToSell = amountToSellSats.Satoshi,
	        ToCoinSymbol = SwapTo,
	        AmountToBuy = amountToBuySats.Satoshi,
	        SwapSessionId = sessionId,
	        SharedSecretHash = sharedSecretHash.ToString()
	    };

		await Http.PostAsJsonAsync($"api/SwapCoordinator/create", postBody);

		var swap = await Http.GetFromJsonAsync<SwapSession?>($"api/SwapCoordinator/session/{postBody.SwapSessionId}");

		if(swap ==null)
		{
		    error = $"swap not created correctly session = {postBody.SwapSessionId}";
		    return;
		}

		myswaps.Add(swap);

		storage.SetSwaps(myswaps);

	    NavigationManager.NavigateTo($"viewswap/{sessionId}");
	}

	protected async Task ViewSwap(string session)
	{
		NavigationManager.NavigateTo($"viewswap/{session}");
	}

    private async Task<(string? Error, WalletAccount? Account, uint256? Secret, uint160? SecretHash)> ConnectWallet(string sessionId)
    {
        Guard.NotNull(_walletAccounts, nameof(_walletAccounts));

        try
        {
            var res = await WalletService.SignMessageAnyAccount(sessionId);
            var data = JsonSerializer.Deserialize<WalletApiMessage<string>>(res);

            Logger.LogInformation(res);

            var sharedSecret = SwapsConfiguration.GenerateSecret(data.signature, sessionId);
            var sharedSecretHash = Hashes.Hash160(sharedSecret.ToBytes());


            if (!NetworkList.Contains(data.network))
            {
                error = $"The network {data.network} is not supported";
                return (error, null, null, null);
            }

            var key = PubKey.RecoverFromMessage(data.content, data.signature);
            if (!key.VerifyMessage(data.content, data.signature))
            {
                error = $"Failed to verify the signature";
                return (error, null, null, null);
            }

            if (!_walletAccounts.Accounts.TryGetValue(data.network, out WalletAccount account))
            {
                WalletAccount newAccount = new WalletAccount
                    {
                        Pubkey = key.ToHex(),
                        Address = data.key,
                        CoinSymbol = data.network,
                        WalletId = data.walletId,
                        AccountId = data.accountId
                    };

                _walletAccounts.Accounts.Add(newAccount.CoinSymbol, newAccount);

                account = newAccount;
            }

            // update balance
            //var resBalance = await WalletService.GetAccountBalance(account.Address, account.WalletId, account.AccountId);
            //var dataBalance = JsonSerializer.Deserialize<WalletApiMessage<WalletApiMessageBalance>>(resBalance);

            //account.Balance = dataBalance.response.balance;

            storage.Set<WalletAccounts?>(_walletAccounts);

            return (null, account, sharedSecret, sharedSecretHash);
        }
        catch (NoBlockcoreWalletException nbwe)
        {
            error = "Not wallet found please install the wallet at blockcore.net";
            return (error, null, null, null);
        }
        catch (Exception e)
        {
            error = e.Message;
            Console.WriteLine(e);
        }

        return (error, null, null, null);
    }

}
