@page "/viewswap/{swapsession}"
@using Blockcore.AtomicSwaps.Shared
@using Blockcore.Consensus.BlockInfo
@using Blockcore.AtomicSwaps.Server.Controllers
@using Blockcore.Consensus.ScriptInfo
@using Blockcore.Consensus.TransactionInfo
@using Blockcore.Features.Wallet.Helpers
@using DBreeze.Utils
@using NBitcoin
@using NBitcoin.Crypto
@using Newtonsoft.Json
@using System.Net
@using Blockcore.Networks.Bitcoin
@using Blockcore.Utilities
@inject HttpClient Http
@inject Storage storage;
@inject GlobalData globalData;
@inject NavigationManager NavigationManager;
@inject ILogger<ViewSwap> Logger;

<PageTitle>View Swaps</PageTitle>

<h1>View Swaps</h1>

<p>This component displays a swap.</p>

<p class="alert-danger">@error</p>

@if (swap != null)
{
    <button class="btn btn-primary" @onclick="RefreshSwap">Refresh Swap</button>

    @if (swap.CoinSeller.SwapTransactionHash != null || swap.CoinBuyer.SwapTransactionHash != null)
    {
        <button class="btn btn-primary" @onclick="RefreshConfirmations">Refresh confirmations</button>
    }

    <p>@swap.SwapSessionId</p>

    <p>@swap.Created</p>
    <p>@swap.Status</p>

    @*=========================Seller========================*@

    <h3>Seller - sends @Money.Satoshis(swap.CoinSeller.Amount) @swap.CoinSeller.CoinSymbol to Buyer</h3>
    <p>Seller Pubkey @swap.CoinSeller.SenderPubkey</p>
    <p>Buyer Pubkey @swap.CoinSeller.ReceiverPubkey</p>

    @if (!string.IsNullOrEmpty(swap.CoinSeller.SwapAddress))
    {
        <p>Swap address:</p>
        <div class="alert alert-secondary" role="alert">
            @swap.CoinSeller.SwapAddress
        </div>
    }

    @if (swap.CoinSeller.SenderPubkey == mypubkey)
    {
        <p><strong> I am the seller</strong></p>

        @if (swap.CoinBuyer.SenderPubkey == null)
        {
            <button class="btn btn-danger" @onclick="DeleteSwap">Delete Swap</button>
        }

        @if (swap.CoinBuyer.SenderPubkey != null && swap.CoinSeller.SwapTransactionHex == null)
        {
            <button class="btn btn-info" @onclick="BuildSellerSwap">Build Seller Swap Transaction</button>
        }

        @if (BuyerTransactionConfirmations > 0 && swap.CoinBuyer.SwapTransactionHex != null && 
             SellerTransactionConfirmations > 0 && swap.CoinSeller.SwapTransactionHex != null)
        {
            if (swap.CoinBuyer.ReceiverExchangeTransactionHex == null)
            {
                <button class="btn btn-success" @onclick="SellerExchangeFunds">Claim Seller Swap Transaction</button>
            }

            <p>Seller Exchange trx Confirmations : @SellerExchangeTransactionConfirmations</p>  
        }

        if (swap.CoinSeller.SwapTransactionHash != null && swap.CoinSeller.RecoveryLockTime < DateTime.UtcNow)
        {
            <button class="btn btn-danger" @onclick="SellerRecoverFunds">Recover Seller Funds</button>

        }
    }

    @if (swap.CoinSeller.SwapTransactionHash != null)
    {
        <p>Hash : @swap.CoinSeller.SwapTransactionHash</p>
        <p>Confirmation : @SellerTransactionConfirmations</p>
        @if (swap.CoinBuyer.RecoveryLockTime.HasValue)
        {
            <p>Locked until : @swap.CoinSeller.RecoveryLockTime?.ToString("dd/MM/yyyy HH:mm:ss") (@((swap.CoinSeller.RecoveryLockTime - DateTime.UtcNow)?.TotalHours.ToString("F")) hours left)</p>
        }
        <p>ScriptHash :</p>
        <div class="alert alert-info" role="alert">
            @Script.FromHex(@swap.CoinSeller.SwapRedeemScriptHex).ToString()
        </div>
    }
    
    @if (swap.CoinBuyer.ReceiverExchangeTransactionHex != null)
    {
        <P>SELLER EXCHANGE SUCCESS</P>

        <p>Exchange trx Confirmations : @SellerExchangeTransactionConfirmations</p>  
    }

    <hr/>

    @*=========================BUYER========================*@

    <h3>Buyer - sends @Money.Satoshis(swap.CoinBuyer.Amount) @swap.CoinBuyer.CoinSymbol to Seller</h3>
    <p>Seller Pubkey @swap.CoinBuyer.SenderPubkey</p>
    <p>Buyer Pubkey @swap.CoinBuyer.ReceiverPubkey</p>

    @if (!string.IsNullOrEmpty(swap.CoinBuyer.SwapAddress))
    {
        <p>Swap address:</p>
        <div class="alert alert-secondary" role="alert">
            @swap.CoinBuyer.SwapAddress
        </div>
    }

    @if (swap.CoinBuyer.SenderPubkey == mypubkey)
    {
        <p><strong>I am the buyer</strong></p>

        @if (swap.CoinSeller.SwapTransactionHash != null)
        {
            @if (SellerTransactionConfirmations > 0 && swap.CoinBuyer.SwapTransactionHash == null)
            {
                <button class="btn btn-info" @onclick="BuildBuyerSwap">Build Buyer Swap Transaction</button>
            }
        }

        @if (BuyerTransactionConfirmations > 0 && swap.CoinBuyer.SwapTransactionHex != null && 
             SellerTransactionConfirmations > 0 && swap.CoinSeller.SwapTransactionHex != null)
        {
            if (string.IsNullOrEmpty(SharedSecret))
            {
                <button class="btn btn-warning" @onclick="ScanForSecretHash">Check the Blockchain for the secret hash</button>
            }
        }

        @if (swap.CoinBuyer.ReceiverExchangeTransactionHex != null)
        {
            if (!string.IsNullOrEmpty(SharedSecret) && swap.CoinSeller.ReceiverExchangeTransactionHex == null)
            {
                <button class="btn btn-success" @onclick="BuyerExchangeFunds">Claim Buyer Swap Transaction</button>
            }

            <p>Buyer Exchange trx Confirmations : @BuyerExchangeTransactionConfirmations</p>  
        }

        if (swap.CoinBuyer.SwapTransactionHash != null && swap.CoinBuyer.RecoveryLockTime < DateTime.UtcNow)
        {
            <button class="btn btn-danger" @onclick="BuyerRecoverFunds">Recover Buyer Funds</button>
        }
    }

    @if (swap.CoinBuyer.SwapTransactionHash != null)
    {
        <p>Hash : @swap.CoinBuyer.SwapTransactionHash</p>
        <p>Confirmation : @BuyerTransactionConfirmations</p>  
        @if (swap.CoinBuyer.RecoveryLockTime.HasValue)
        {
            <p>Locked until : @swap.CoinBuyer.RecoveryLockTime?.ToString("dd/MM/yyyy HH:mm:ss") (@((swap.CoinBuyer.RecoveryLockTime - DateTime.UtcNow)?.TotalHours.ToString("F")) hours left)</p>
        }    
        <p>ScriptHash :</p>
        <div class="alert alert-info" role="alert">
            @Script.FromHex(@swap.CoinBuyer.SwapRedeemScriptHex).ToString()
        </div>
    }

    @if (swap.CoinSeller.SenderPubkey != mypubkey && swap.CoinBuyer.SenderPubkey == null)
    {
        <button class="btn btn-success" @onclick="BuyerTakeSwap">Take Swap</button>
    }

    @if (swap.CoinSeller.ReceiverExchangeTransactionHex != null)
    {
        <P>BUYER EXCHANGE SUCCESS</P>

        <p>Exchange trx Confirmations : @BuyerExchangeTransactionConfirmations</p>  
    }

}

@code {
    private SwapSession swap;

    string error;
    
    [Parameter]
    public string swapSession { get; set; }

    string SharedSecret { get; set; }

    string mypubkey;

    int SellerTransactionConfirmations;
    int BuyerTransactionConfirmations;
    int SellerExchangeTransactionConfirmations;
    int BuyerExchangeTransactionConfirmations;
    int SellerRecoveryTransactionConfirmations;
    int BuyerRecoveryTransactionConfirmations;

    protected override async Task OnInitializedAsync()
    {
        mypubkey = storage.GetWalletPubkey();

        swap = await Http.GetFromJsonAsync<SwapSession>($"api/SwapCoordinator/session/{swapSession}");

        await this.RefreshConfirmations();
    }

    private async Task DeleteSwap()
    {
        // this method is of course problematic because anyone can delete using an api call
        // we need to add pubkey validation to each request to the api

        if (swap.CoinSeller.SenderPubkey == mypubkey || swap.CoinBuyer.SenderPubkey == mypubkey)
        {
            await Http.DeleteAsync($"api/SwapCoordinator/delete/{swapSession}");
        }
        else
        {
            error = "Only the owner can delete a swap";
            return;
        }

        var swaps = storage.GetSwaps();
        if (swaps != null)
        {
            var myswap = swaps.FirstOrDefault(s => s.SwapSessionId == swapSession);
            if (myswap != null)
            {
                swaps.Remove(myswap);
                storage.SetSwaps(swaps);
            }
        }

        NavigationManager.NavigateTo($"fetchswaps");
    }

    private async Task BuyerTakeSwap()
    {
        ExtKey.UseBCForHMACSHA512 = true;
        NBitcoin.Crypto.Hashes.UseBCForHMACSHA512 = true;

        Networks.Network network = globalData.Networks[swap.CoinBuyer.CoinSymbol];
        AccountInfo accountInfo = storage.GetAccountInfo(network.CoinTicker);

        if (accountInfo == null)
        {
            error = "Please scan the wallet";
            return;
        }

        ExtPubKey accountExtPubKey = ExtPubKey.Parse(accountInfo.ExtPubKey, network);
        PubKey pubkey = HdOperations.GeneratePublicKey(accountExtPubKey, accountInfo.LastFetchIndex, false);

        swap.Status = "Matched";
        swap.CoinBuyer.SenderPubkey = mypubkey;
        swap.CoinSeller.ReceiverPubkey = mypubkey;

        var myswaps = storage.GetSwaps();

        if (myswaps == null)
        {
            myswaps = new List<SwapSession>();
            storage.SetSwaps(myswaps);
        }

        await Http.PostAsJsonAsync($"api/SwapCoordinator/update", swap);

        myswaps.Add(swap);
        storage.SetSwaps(myswaps);

    }

    private async Task BuildSellerSwap()
    {
        if (swap.CoinSeller.SenderPubkey != mypubkey)
            throw new Exception("seller pubkey was changed");

        BuildSideSwap(swap.CoinSeller, DateTime.UtcNow.AddHours(48));

        await Http.PostAsJsonAsync($"api/SwapCoordinator/update", swap);

        await this.RefreshSwap();

        await this.Broadcast(swap.CoinSeller.CoinSymbol, swap.CoinSeller.SwapTransactionHex);
    }

    private async Task BuildBuyerSwap()
    {
        if (swap.CoinBuyer.SenderPubkey != mypubkey)
            throw new Exception("buyer pubkey was changed");

        BuildSideSwap(swap.CoinBuyer, swap.CoinSeller.RecoveryLockTime.Value.AddHours(-24));

        await Http.PostAsJsonAsync($"api/SwapCoordinator/update", swap);

        await this.RefreshSwap();

        await this.Broadcast(swap.CoinBuyer.CoinSymbol, swap.CoinBuyer.SwapTransactionHex);
    }

    private void BuildSideSwap(SwapSessionCoin swapSessionCoin, DateTime recoveryLockTime)
    {
        ExtKey.UseBCForHMACSHA512 = true;
        NBitcoin.Crypto.Hashes.UseBCForHMACSHA512 = true;

        Networks.Network network = globalData.Networks[swapSessionCoin.CoinSymbol];

        swapSessionCoin.RecoveryLockTime = recoveryLockTime;

        AccountInfo? accountInfo = storage.GetAccountInfo(network.CoinTicker);
        Guard.NotNull(accountInfo, nameof(accountInfo));

        var fee = network.MinRelayTxFee * 3;
        if (!GlobalData.FindInputs(network, storage, swapSessionCoin.Amount, fee, out List<UtxoData> balancesList))
        {
            error = "not enough balance";
            return;
        }

        var utxos = GlobalData.AddPrivateKeys(network, storage, balancesList);
        
        PubKey pubKey = GlobalData.GetNextAvailableAddress(network, storage);

        RedeemType redeemType = HdOperations.GetPurpose(accountInfo.Path) == 44 ? RedeemType.P2SH :
            HdOperations.GetPurpose(accountInfo.Path) == 88 ? RedeemType.WitnessV0 : RedeemType.P2SH;

        var change = redeemType == RedeemType.P2SH ? 
            pubKey.GetAddress(network).ScriptPubKey : 
            pubKey.GetSegwitAddress(network).ScriptPubKey;

        var transactionContext = SwapBuilder.CreateSwapTransaction(network,
            uint160.Parse(swap.SharedSecretHash),
            new PubKey(swapSessionCoin.SenderPubkey),
            change,
            new PubKey(swapSessionCoin.ReceiverPubkey),
            swapSessionCoin.RecoveryLockTime.Value, 
            swapSessionCoin.Amount, 
            utxos, 
            new FeeRate(new Money(fee)),
            redeemType);

        swapSessionCoin.SwapTransactionHex = transactionContext.Transaction.ToHex(network.Consensus.ConsensusFactory);
        swapSessionCoin.SwapTransactionHash = transactionContext.Transaction.GetHash().ToString();
        swapSessionCoin.SwapRedeemScriptHex = transactionContext.RedeemScript.ToHex();
        swapSessionCoin.SwapAddress = transactionContext.SwapAddress;
    }

    private async Task RefreshSwap()
    {
        swap = await Http.GetFromJsonAsync<SwapSession>($"api/SwapCoordinator/session/{swapSession}");

        var myswaps = storage.GetSwaps();
        if (myswaps != null)
        {
            var swapStore = myswaps.FirstOrDefault(s => s.SwapSessionId == swap.SwapSessionId);
            if (swapStore != null)
            {
                myswaps.Remove(swapStore);
                myswaps.Add(swap);
                storage.SetSwaps(myswaps);
            }
        }
    }

    private async Task Broadcast(string coinSymbol, string trxHex)
    {
        var indexer = globalData.Indexers.First(f => f.Symbol == coinSymbol);

        var url = $"/command/send";
        var result = await Http.PostAsync(indexer.Url + url, new StringContent(trxHex));

        if (result.StatusCode != HttpStatusCode.OK)
        {
            error = "Received status code " + result.StatusCode.ToString();
        }
    }

    private async Task RefreshConfirmations()
    {
        if (swap.CoinSeller.SwapTransactionHash != null)
        {
            var indexer = globalData.Indexers.First(f => f.Symbol == swap.CoinSeller.CoinSymbol);
            var url = $"/query/transaction/{swap.CoinSeller.SwapTransactionHash}";
            var res = await Http.GetFromJsonAsync<TransactionData>(indexer.Url + url);
            SellerTransactionConfirmations = res?.confirmations ?? 0;
        }

        if (swap.CoinBuyer.SwapTransactionHash != null)
        {
            var indexer = globalData.Indexers.First(f => f.Symbol == swap.CoinBuyer.CoinSymbol);
            var url = $"/query/transaction/{swap.CoinBuyer.SwapTransactionHash}";
            var res = await Http.GetFromJsonAsync<TransactionData>(indexer.Url + url);
            BuyerTransactionConfirmations = res?.confirmations ?? 0;
        }

        if (swap.CoinBuyer.ReceiverExchangeTransactionHex != null)
        {
            var indexer = globalData.Indexers.First(f => f.Symbol == swap.CoinBuyer.CoinSymbol);
            var url = $"/query/transaction/{swap.CoinBuyer.ReceiverExchangeTransactionHash}";
            var res = await Http.GetFromJsonAsync<TransactionData>(indexer.Url + url);
            SellerExchangeTransactionConfirmations = res?.confirmations ?? 0;
        }

        if (swap.CoinSeller.ReceiverExchangeTransactionHex != null)
        {
            var indexer = globalData.Indexers.First(f => f.Symbol == swap.CoinSeller.CoinSymbol);
            var url = $"/query/transaction/{swap.CoinSeller.ReceiverExchangeTransactionHash}";
            var res = await Http.GetFromJsonAsync<TransactionData>(indexer.Url + url);
            BuyerExchangeTransactionConfirmations = res?.confirmations ?? 0;
        }
    }

    private async Task SellerExchangeFunds()
    {
        ExtKey.UseBCForHMACSHA512 = true;
        NBitcoin.Crypto.Hashes.UseBCForHMACSHA512 = true;

        if (swap.CoinBuyer.ReceiverPubkey != mypubkey)
            throw new Exception("seller pubkey was changed");

        Networks.Network network = globalData.Networks[swap.CoinBuyer.CoinSymbol];

        var sharedSecret = GlobalData.GenerateSecret(network, storage, swap.SwapSessionId);
        var extendedKey = ExtKey.Parse(storage.GetWalletPrivkey(), network);

        ExchangeSwapFund(swap.CoinBuyer, sharedSecret, extendedKey.PrivateKey);

        await Http.PostAsJsonAsync($"api/SwapCoordinator/update", swap);

        await this.RefreshSwap();

        await this.Broadcast(swap.CoinBuyer.CoinSymbol, swap.CoinBuyer.ReceiverExchangeTransactionHex);
    }

    private async Task BuyerExchangeFunds()
    {
        ExtKey.UseBCForHMACSHA512 = true;
        NBitcoin.Crypto.Hashes.UseBCForHMACSHA512 = true;

        if (swap.CoinSeller.ReceiverPubkey != mypubkey)
            throw new Exception("buyer pubkey was changed");

        if (string.IsNullOrEmpty(this.SharedSecret))
            throw new Exception("Missing shared secret");

        var walletWrods = storage.GetWalletWords();
        var extendedKey = HdOperations.GetExtendedKey(walletWrods);

        ExchangeSwapFund(swap.CoinSeller, new uint256(this.SharedSecret), extendedKey.PrivateKey);

        await Http.PostAsJsonAsync($"api/SwapCoordinator/update", swap);

        await this.RefreshSwap();

        await this.Broadcast(swap.CoinSeller.CoinSymbol, swap.CoinSeller.ReceiverExchangeTransactionHex);
    }

    private void ExchangeSwapFund(SwapSessionCoin swapSessionCoin, uint256 sharedSecret, Key privateKey)
    {
        // double check the keys
        if (mypubkey != swapSessionCoin.ReceiverPubkey)
            throw new Exception("Invalid key");

        Networks.Network network = globalData.Networks[swapSessionCoin.CoinSymbol];

        var transaciton = network.Consensus.ConsensusFactory.CreateTransaction(swapSessionCoin.SwapTransactionHex);
        var redeemScript = Script.FromHex(swapSessionCoin.SwapRedeemScriptHex);

        long fee = network.MinRelayTxFee * 3;

        PubKey pubKey = GlobalData.GetNextAvailableAddress(network, storage);

        var exchangeTransaction = SwapBuilder.CreateSwapSpendTransaction(
            network,
            transaciton,
            redeemScript,
            sharedSecret,
            pubKey.GetAddress(network).ScriptPubKey,
            privateKey,
            new FeeRate(new Money(fee)));

        swapSessionCoin.ReceiverExchangeTransactionHex = exchangeTransaction.ToHex(network.Consensus.ConsensusFactory);
        swapSessionCoin.ReceiverExchangeTransactionHash = exchangeTransaction.GetHash().ToString();
    }


    private async Task ScanForSecretHash()
    {
        Networks.Network network = globalData.Networks[swap.CoinBuyer.CoinSymbol];

        if (swap.CoinBuyer.ReceiverExchangeTransactionHex != null)
        {
            var transaciton = network.Consensus.ConsensusFactory.CreateTransaction(swap.CoinBuyer.ReceiverExchangeTransactionHex);

            var secret = SwapScripts.GetSecretFromScriptSig(transaciton);

            this.SharedSecret = secret.ToString();
        }

        var indexer = globalData.Indexers.First(f => f.Symbol == swap.CoinBuyer.CoinSymbol);
        var url = $"/query/transaction/{swap.CoinBuyer.SwapTransactionHash}";
        var res = await Http.GetFromJsonAsync<TransactionData>(indexer.Url + url);

        foreach (var output in res.outputs)
        {
            if (output.address == swap.CoinBuyer.SwapAddress)
            {
                if (!string.IsNullOrEmpty(output.spentInTransaction))
                {
                    url = $"/query/transaction/{output.spentInTransaction}/hex";
                    var trxHex = await Http.GetStringAsync(indexer.Url + url);

                    if (res != null)
                    {
                        swap.CoinBuyer.ReceiverExchangeTransactionHex = trxHex; // the other side didn't tell us they spent the coins

                        var exchangeTransaciton = network.Consensus.ConsensusFactory.CreateTransaction(trxHex);

                        var secret = SwapScripts.GetSecretFromScriptSig(exchangeTransaciton);

                        this.SharedSecret = secret.ToString();
                    }
                }
            }
        }
    }

    private async Task SellerRecoverFunds()
    {
        ExtKey.UseBCForHMACSHA512 = true;
        NBitcoin.Crypto.Hashes.UseBCForHMACSHA512 = true;

        if (swap.CoinSeller.SenderPubkey != mypubkey)
            throw new Exception("buyer pubkey was changed");

        var walletWrods = storage.GetWalletWords();
        var extendedKey = HdOperations.GetExtendedKey(walletWrods);

        RecoverFunds(swap.CoinSeller, extendedKey.PrivateKey);

        await Http.PostAsJsonAsync($"api/SwapCoordinator/update", swap);

        await this.RefreshSwap();

        await this.Broadcast(swap.CoinSeller.CoinSymbol, swap.CoinSeller.SenderRecoveryTransactionHex);
    }

    private async Task BuyerRecoverFunds()
    {
        ExtKey.UseBCForHMACSHA512 = true;
        NBitcoin.Crypto.Hashes.UseBCForHMACSHA512 = true;

        if (swap.CoinBuyer.SenderPubkey != mypubkey)
            throw new Exception("buyer pubkey was changed");

        var walletWrods = storage.GetWalletWords();
        var extendedKey = HdOperations.GetExtendedKey(walletWrods);

        RecoverFunds(swap.CoinBuyer, extendedKey.PrivateKey);

        await Http.PostAsJsonAsync($"api/SwapCoordinator/update", swap);

        await this.RefreshSwap();

        await this.Broadcast(swap.CoinBuyer.CoinSymbol, swap.CoinBuyer.SenderRecoveryTransactionHex);
    }

    private void RecoverFunds(SwapSessionCoin swapSessionCoin, Key privateKey)
    {
        if (mypubkey != swapSessionCoin.SenderPubkey)
            throw new Exception("Invalid key");

        Networks.Network network = globalData.Networks[swapSessionCoin.CoinSymbol];

        var transaciton = network.Consensus.ConsensusFactory.CreateTransaction(swapSessionCoin.SwapTransactionHex);
        var redeemScript = Script.FromHex(swapSessionCoin.SwapRedeemScriptHex);

        long fee = network.MinRelayTxFee * 3;

        PubKey pubKey = GlobalData.GetNextAvailableAddress(network, storage);

        var recoveryTransaction = SwapBuilder.CreateSwapRecoveryTransaction(
            network,
            transaciton,
            redeemScript,
            pubKey.GetAddress(network).ScriptPubKey,
            privateKey,
            new FeeRate(new Money(fee)),
            swapSessionCoin.RecoveryLockTime!.Value);

        swapSessionCoin.SenderRecoveryTransactionHex = recoveryTransaction.ToHex(network.Consensus.ConsensusFactory);
        swapSessionCoin.SenderRecoveryTransactionHash = recoveryTransaction.GetHash().ToString();
    }
}
