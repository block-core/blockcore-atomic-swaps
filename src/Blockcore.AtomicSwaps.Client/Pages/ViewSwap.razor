@page "/viewswap/{swapsession}"
@using Blockcore.AtomicSwaps.Shared
@using Blockcore.Consensus.ScriptInfo
@using NBitcoin
@using System.Text.Json
@using Blockcore.AtomicSwaps.BlockcoreWallet
@using Blockcore.AtomicSwaps.Client.Services
@using Blockcore.Utilities
@using NBitcoin.DataEncoders
@using JsonSerializer = System.Text.Json.JsonSerializer

@inject HttpClient Http
@inject Storage storage;
@inject SwapsConfiguration SwapsConfiguration;
@inject NavigationManager NavigationManager;
@inject ILogger<ViewSwap> Logger;
@inject IBlockcoreWalletConnector WalletConnector
@inject IBlockchainApiService BlockchainApiService;
@inject IWalletService WalletService
@inject ISnackbarService SnackbarService

<PageTitle>View Swaps</PageTitle>

<MudText Align="Align.Center" Typo="Typo.h4">View Swaps</MudText>
<MudText Align="Align.Center" Class="mb-8 mt-8">


</MudText>

@if (swap != null)
{
    @*=========================Swap info========================*@
    <MudCard Class="mb-5">
        <MudCardHeader>
            <CardHeaderAvatar>
                <MudAvatarGroup Max="2" Spacing="3" MaxColor="Color.Primary">
                    @{
                        var makerCoinImg = String.Format("https://chains.blockcore.net/assets/{0}/icon.png", @swap.SwapMaker.CoinSymbol);
                        var takerCoinImg = String.Format("https://chains.blockcore.net/assets/{0}/icon.png", @swap.SwapTaker.CoinSymbol);
                    }
                    <MudAvatar Image="@makerCoinImg" />
                    <MudAvatar Image="@takerCoinImg" />
                </MudAvatarGroup>
            </CardHeaderAvatar>
            <CardHeaderContent>
                <MudText Typo="Typo.body1">@swap.SwapMaker.CoinSymbol for @swap.SwapTaker.CoinSymbol</MudText>
            </CardHeaderContent>
            <CardHeaderActions>
                <MudIconButton Icon="@Icons.Material.Filled.Settings" Color="Color.Default" />
            </CardHeaderActions>
        </MudCardHeader>
        <MudCardContent>
            <MudText Typo="Typo.body1">Swap @Money.Satoshis(swap.SwapMaker.Amount) @swap.SwapMaker.CoinSymbol for @Money.Satoshis(swap.SwapTaker.Amount) @swap.SwapTaker.CoinSymbol</MudText>
            <MudText Typo="Typo.body2">Created - @swap.Created</MudText>            <p>Status - @swap.Status</p>
            @if (mypubkeyTakerSide == null && mypubkeyMakerSide == null)
            {
                <p><strong>Not my swap</strong></p>
            }
            else if (swap.SwapMaker.SenderPubkey == mypubkeyMakerSide)
            {
                <p class="text-success"><strong> I am the maker</strong></p>
            }
            else if (swap.SwapTaker.SenderPubkey == mypubkeyTakerSide)
            {
                <p class="text-success"><strong>I am the taker</strong></p>
            }
            else
            {
                <p><strong>Not my swap</strong></p>
            }

        </MudCardContent>
        <MudCardActions>
            <MudButton Variant="Variant.Filled" Color="Color.Primary" @onclick="RefreshSwap">Refresh Swap</MudButton>

            @if (swap.SwapMaker.SwapTransactionHash != null || swap.SwapTaker.SwapTransactionHash != null)
            {
                <MudButton Variant="Variant.Filled" Color="Color.Primary" @onclick="RefreshConfirmations">Refresh confirmations</MudButton>

            }
        </MudCardActions>
    </MudCard>


    <MudTabs Elevation="2" Rounded="true" ApplyEffectsToContainer="true" PanelClass="pa-6">
        <MudTabPanel Text="Step 1">

            @*=========================Step1 - swap created by maker ========================*@

            <h3>Step 1 - swap created by the maker</h3>

            <p>Maker Pubkey - @swap.SwapMaker.SenderPubkey</p>
            <p>Shared secret hash - @swap.SharedSecretHash</p>

            @if (swap.SwapMaker.SenderPubkey == mypubkeyMakerSide && swap.SwapTaker.SenderPubkey == null)
            {
                <button class="btn btn-danger" @onclick="DeleteSwap">Delete Swap</button>
            }

        </MudTabPanel>
        <MudTabPanel Text="Step 2">


            @*=========================Step2 - swap locked by taker ========================*@

            <h3>Step 2 - swap locked by taker</h3>

            <p>Taker Pubkey - @swap.SwapTaker.SenderPubkey</p>

            @if (swap.SwapMaker.SenderPubkey != mypubkeyMakerSide && swap.SwapTaker.SenderPubkey == null)
            {
                if (hasWallet)
                {
                    if (_walletAccounts.Connected)
                    {
                        <button class="btn btn-success" @onclick="TakerAcceptSwap">Claim This Swap</button>
                    }
                    else
                    {
                        <p><a href="/walletconnect">Connect a wallet to participate in this swap </a></p>
                    }
                }
                else
                {
                    <p>Not wallet found please install the wallet at blockcore.net to participate in this swap</p>
                }
            }



        </MudTabPanel>
        <MudTabPanel Text="Step 3">
            @*=========================Step3 - maker creates swap trx ========================*@

            <h3>Step 3 - maker funds the swap</h3>

            <p><strong>Maker sends @Money.Satoshis(swap.SwapMaker.Amount + swap.SwapMaker.NetworkFee + swap.SwapMaker.ServiceFee) @swap.SwapMaker.CoinSymbol</strong></p>
            @*   <p>Swap amount = @Money.Satoshis(swap.SwapMaker.Amount) @swap.SwapMaker.CoinSymbol</p>
        <p>Network fee = @Money.Satoshis(swap.SwapMaker.NetworkFee) @swap.SwapMaker.CoinSymbol</p>
        <p>Service fee = @Money.Satoshis(swap.SwapMaker.ServiceFee) @swap.SwapMaker.CoinSymbol</p>
        *@
            @if (swap.SwapMaker.SwapTransactionHash != null)
            {
                var url = $"{explorerUrl}/{swap.SwapMaker.CoinSymbol}/explorer/transaction/{swap.SwapMaker.SwapTransactionHash}";

                <p>Maker on @swap.SwapMaker.CoinSymbol, confirmations - @MakerSwapTransactionConfirmations, trx - <a href="@url" target="_blank">@swap.SwapMaker.SwapTransactionHash</a></p>
                @if (swap.SwapMaker.RecoveryLockTime.HasValue)
                {
                    <p>In progress until : @swap.SwapMaker.RecoveryLockTime?.ToString("dd/MM/yyyy HH:mm:ss") (@((swap.SwapMaker.RecoveryLockTime - DateTime.UtcNow)?.TotalHours.ToString("F")) hours left)</p>
                }

                <button class="btn btn-info" @onclick="ShowScriptMaker" type="button">Show scripts</button>
                <br />
                <p hidden="@ShowScriptMakerFlag">
                <p>Swap address:</p>
                <div class="alert alert-secondary" role="alert">
                        @swap.SwapMaker.SwapAddress
                </div>

                <p>ScriptHash :</p>
                <div class="alert alert-info" role="alert">
                        @Script.FromHex(@swap.SwapMaker.SwapRedeemScriptHex).ToString()
                </div>
                </p>
            }

            @if (swap.SwapMaker.SenderPubkey == mypubkeyMakerSide)
            {
                @if (swap.SwapTaker.SenderPubkey != null && swap.SwapMaker.SwapTransactionHash == null)
                {
                    <button class="btn btn-info" @onclick="BuildMakerSwap">Build Maker Swap Transaction</button>
                }
            }
        </MudTabPanel>
        <MudTabPanel Text="Step 4">
            @*=========================Step4 - taker creates swap trx ========================*@

            <h3>Step 4 - taker funds the swap</h3>

            <p><strong>Taker sends @Money.Satoshis(swap.SwapTaker.Amount + swap.SwapTaker.NetworkFee + swap.SwapTaker.ServiceFee) @swap.SwapTaker.CoinSymbol</strong></p>
            @*    <p>Swap amount = @Money.Satoshis(swap.SwapTaker.Amount) @swap.SwapTaker.CoinSymbol</p>
        <p>Network fee = @Money.Satoshis(swap.SwapTaker.NetworkFee) @swap.SwapTaker.CoinSymbol</p>
        <p>Service fee = @Money.Satoshis(swap.SwapTaker.ServiceFee) @swap.SwapTaker.CoinSymbol</p>
        *@
            @if (swap.SwapTaker.SwapTransactionHash != null)
            {
                var url = $"{explorerUrl}/{swap.SwapTaker.CoinSymbol}/explorer/transaction/{swap.SwapTaker.SwapTransactionHash}";

                <p>Taker on @swap.SwapTaker.CoinSymbol, confirmations : @TakerSwapTransactionConfirmations, trx - <a href="@url" target="_blank">@swap.SwapTaker.SwapTransactionHash</a></p>
                @if (swap.SwapTaker.RecoveryLockTime.HasValue)
                {
                    <p>In progress until : @swap.SwapTaker.RecoveryLockTime?.ToString("dd/MM/yyyy HH:mm:ss") (@((swap.SwapTaker.RecoveryLockTime - DateTime.UtcNow)?.TotalHours.ToString("F")) hours left)</p>
                }

                <button class="btn btn-info" @onclick="ShowScriptTaker" type="button">Show scripts</button>
                <br />
                <p hidden="@ShowScriptTakerFlag">

                <p>Swap address:</p>
                <div class="alert alert-secondary" role="alert">
                        @swap.SwapTaker.SwapAddress
                </div>

                <p>ScriptHash :</p>
                <div class="alert alert-info" role="alert">
                        @Script.FromHex(@swap.SwapTaker.SwapRedeemScriptHex).ToString()
                </div>
                </p>
            }

            @if (swap.SwapTaker.SenderPubkey == mypubkeyTakerSide)
            {
                @if (swap.SwapMaker.SwapTransactionHash != null)
                {
                    @if (MakerSwapTransactionConfirmations > 0 && swap.SwapTaker.SwapTransactionHash == null)
                    {
                        <button class="btn btn-info" @onclick="BuildTakerSwap">Build Taker Swap Transaction</button>
                    }
                }
            }

        </MudTabPanel>
        <MudTabPanel Text="Step 5">
            @*=========================Step5 - maker creates exchange trx (reveal secret) ========================*@

            <h3>Step 5 - maker claims coins (reveal secret)</h3>

            <p><strong>Maker receives @Money.Satoshis(swap.SwapTaker.Amount) @swap.SwapTaker.CoinSymbol</strong></p>

            @if (@swap.SwapTaker.ExchangeTransactionHash != null)
            {
                var url = $"{explorerUrl}/{swap.SwapTaker.CoinSymbol}/explorer/transaction/{swap.SwapTaker.ExchangeTransactionHash}";

                <p>Maker on @swap.SwapTaker.CoinSymbol, Confirmations : @MakerExchangeTransactionConfirmations, trx - <a href="@url" target="_blank">@swap.SwapTaker.ExchangeTransactionHash</a></p>
                <P class="text-success"><strong>MAKER EXCHANGE SUCCESS</strong></P>
            }

            @if (swap.SwapMaker.SenderPubkey == mypubkeyMakerSide)
            {
                if (TakerSwapTransactionConfirmations > 0 && swap.SwapTaker.SwapTransactionHash != null &&
                MakerSwapTransactionConfirmations > 0 && swap.SwapMaker.SwapTransactionHash != null)
                {
                    if (swap.SwapTaker.ExchangeTransactionHash == null && swap.SwapMaker.RecoveryTransactionHash == null)
                    {
                        <button class="btn btn-success" @onclick="MakerExchangeFunds1">Claim Maker Coins</button>
                    }
                }

                if (swap.SwapMaker.SwapTransactionHash != null && swap.SwapMaker.ExchangeTransactionHash == null && swap.SwapMaker.RecoveryLockTime < DateTime.UtcNow)
                {
                    <br />

                    <h4>Maker claims recover trx (timeout)</h4>

                    <p><strong>Maker takes back @Money.Satoshis(swap.SwapMaker.Amount) @swap.SwapMaker.CoinSymbol</strong></p>

                    if (swap.SwapMaker.RecoveryTransactionHash == null)
                    {
                        <button class="btn btn-danger" @onclick="MakerRecoverFunds1">Recover Maker Funds</button>
                    }
                    else
                    {
                        <P class="text-warning"><strong>MAKER RECOVER SUCCESS</strong></P>
                    }
                }
            }

        </MudTabPanel>
        <MudTabPanel Text="Step 6">

            @*=========================Step6 - Taker creates exchange trx (discover secret) ========================*@

            <h3>Step 6 - taker claims coins (discover secret)</h3>

            <p><strong>Taker receives @Money.Satoshis(swap.SwapMaker.Amount) @swap.SwapMaker.CoinSymbol</strong></p>

            @if (swap.SwapMaker.ExchangeTransactionHash != null)
            {
                var url = $"{explorerUrl}/{swap.SwapMaker.CoinSymbol}/explorer/transaction/{swap.SwapMaker.ExchangeTransactionHash}";

                <p>Taker on @swap.SwapMaker.CoinSymbol, Confirmations : @TakerExchangeTransactionConfirmations, trx - <a href="@url" target="_blank">@swap.SwapMaker.ExchangeTransactionHash</a></p>
                <P class="text-success"><strong>TAKER EXCHANGE SUCCESS</strong></P>
            }

            @if (swap.SwapTaker.SenderPubkey == mypubkeyTakerSide)
            {
                @if (TakerSwapTransactionConfirmations > 0 && swap.SwapTaker.SwapTransactionHash != null &&
               MakerSwapTransactionConfirmations > 0 && swap.SwapMaker.SwapTransactionHash != null)
                {
                    @if (swap.SwapMaker.ExchangeTransactionHash == null && swap.SwapTaker.RecoveryTransactionHash == null)
                    {
                        if (string.IsNullOrEmpty(SharedSecret))
                        {
                            <button class="btn btn-warning" @onclick="ScanForSecretHash">Check the Blockchain for the secret hash</button>
                        }
                        else
                        {
                            <button class="btn btn-success" @onclick="TakerExchangeFunds1">Claim Taker Swap Transaction</button>
                        }
                    }
                }

                if (swap.SwapTaker.SwapTransactionHash != null && swap.SwapTaker.ExchangeTransactionHash == null && swap.SwapTaker.RecoveryLockTime < DateTime.UtcNow)
                {
                    <br />

                    <h4>Taker claims recover trx (timeout)</h4>

                    <p><strong>Taker takes back @Money.Satoshis(swap.SwapTaker.Amount) @swap.SwapTaker.CoinSymbol</strong></p>

                    if (swap.SwapTaker.RecoveryTransactionHash == null)
                    {
                        <button class="btn btn-danger" @onclick="TakerRecoverFunds1">Recover Taker Funds</button>
                    }
                    else
                    {
                        <P class="text-warning"><strong>TAKER RECOVER SUCCESS</strong></P>
                    }
                }
            }

        </MudTabPanel>
    </MudTabs>

}

@code {
    private SwapSession? swap;

    string error;

    [Parameter]
    public string swapSession { get; set; }

    string SharedSecret { get; set; }

    string mypubkeyMakerSide;
    string mypubkeyTakerSide;

    int MakerSwapTransactionConfirmations;
    int TakerSwapTransactionConfirmations;
    int MakerExchangeTransactionConfirmations;
    int TakerExchangeTransactionConfirmations;
    int MakerRecoveryTransactionConfirmations;
    int TakerRecoveryTransactionConfirmations;

    WalletAccounts _walletAccounts = new();

    private bool hasWallet;

    private string explorerUrl = String.Empty;

    protected override async Task OnInitializedAsync()
    {
        hasWallet = await WalletConnector.HasBlockcoreWallet();
        _walletAccounts = storage.GetOrCreate<WalletAccounts>();

        string? swapRes = await Http.GetStringAsync($"api/SwapCoordinator/session/{swapSession}");

        if (string.IsNullOrEmpty(swapRes))
        {
            error = $"Swap not found!";
            await SnackbarService.ShowMessage(error, Defaults.Classes.Position.BottomEnd, Severity.Error);
            return;
        }

        swap = JsonSerializer.Deserialize<SwapSession>(swapRes, new JsonSerializerOptions
            {
                PropertyNamingPolicy = JsonNamingPolicy.CamelCase,
                WriteIndented = true
            });

        if (swap != null)
        {
            Guard.NotNull(swap.SwapMaker, nameof(swap.SwapMaker));
            Guard.NotNull(swap.SwapTaker, nameof(swap.SwapTaker));

            // if I am the maker this is where my keys will be found
            if (swap.SwapMaker.SenderPubkey != null)
            {
                Guard.NotNull(swap.SwapTaker.ReceiverPubkey, nameof(swap.SwapTaker.ReceiverPubkey));

                var accountMakerSide = _walletAccounts.TryGetAccountByKey(swap.SwapMaker.SenderPubkey);
                mypubkeyMakerSide = accountMakerSide?.Pubkey;

                var accountTakerSide = _walletAccounts.TryGetAccountByKey(swap.SwapTaker.ReceiverPubkey);
                mypubkeyTakerSide = accountTakerSide?.Pubkey;
            }

            // if I am the taker this is where my keys will be found
            if (mypubkeyMakerSide == null && swap.SwapTaker.SenderPubkey != null)
            {
                Guard.NotNull(swap.SwapMaker.ReceiverPubkey, nameof(swap.SwapMaker.ReceiverPubkey));

                var accountMakerSide = _walletAccounts.TryGetAccountByKey(swap.SwapMaker.ReceiverPubkey);
                mypubkeyMakerSide = accountMakerSide?.Pubkey;

                var accountTakerSide = _walletAccounts.TryGetAccountByKey(swap.SwapTaker.SenderPubkey);
                mypubkeyTakerSide = accountTakerSide?.Pubkey;
            }
        }

        await this.RefreshConfirmations();

        try
        {
            explorerUrl = await storage.ExplorerUrl();
        }
        catch (Exception ex)
        {
            error = ex.Message;
            await SnackbarService.ShowMessage(error, Defaults.Classes.Position.BottomEnd, Severity.Error);
        }

    }

    private async Task DeleteSwap()
    {
        // this method is of course problematic because anyone can delete using an api call
        // we need to add pubkey validation to each request to the api

        if (swap.SwapMaker.SenderPubkey == mypubkeyMakerSide || swap.SwapTaker.SenderPubkey == mypubkeyTakerSide)
        {
            await Http.DeleteAsync($"api/SwapCoordinator/delete/{swapSession}");
        }
        else
        {
            error = "Only the owner can delete a swap";
            await SnackbarService.ShowMessage(error, Defaults.Classes.Position.BottomEnd, Severity.Error);
            return;
        }

        var swaps = storage.GetSwaps();
        if (swaps != null)
        {
            var myswap = swaps.FirstOrDefault(s => s.SwapSessionId == swapSession);
            if (myswap != null)
            {
                swaps.Remove(myswap);
                storage.SetSwaps(swaps);
            }
        }

        NavigationManager.NavigateTo($"/");
    }

    private async Task TakerAcceptSwap()
    {
        ExtKey.UseBCForHMACSHA512 = true;
        NBitcoin.Crypto.Hashes.UseBCForHMACSHA512 = true;

        Guard.Assert(mypubkeyMakerSide == null);
        Guard.Assert(mypubkeyTakerSide == null);

        var accountMaker = _walletAccounts.FindAccount(swap.SwapMaker.CoinSymbol);
        var accountTaker = _walletAccounts.FindAccount(swap.SwapTaker.CoinSymbol);

        mypubkeyTakerSide = accountTaker.Pubkey;
        mypubkeyMakerSide = accountMaker.Pubkey;

        swap.Status = SwapsDataStatus.InProgress;
        swap.SwapTaker.SenderPubkey = mypubkeyTakerSide;
        swap.SwapMaker.ReceiverPubkey = mypubkeyMakerSide;

        var myswaps = storage.GetSwaps();

        if (myswaps == null)
        {
            myswaps = new List<SwapSession>();
            storage.SetSwaps(myswaps);
        }

        await Http.PostAsJsonAsync($"api/SwapCoordinator/update", swap);

        myswaps.Add(swap);
        storage.SetSwaps(myswaps);
    }

    private async Task BuildMakerSwap()
    {
        if (swap.SwapMaker.SenderPubkey != mypubkeyMakerSide)
            throw new Exception("Maker pubkey was changed");

        await BuildSideSwap1(swap.SwapMaker, DateTime.UtcNow.AddHours(48));

        await PostSwap(swap);

        await this.RefreshSwap();

        await this.BlockchainApiService.Broadcast(swap.SwapMaker.CoinSymbol, swap.SwapMaker.SwapTransactionHex);
    }

    private async Task BuildTakerSwap()
    {
        if (swap.SwapTaker.SenderPubkey != mypubkeyTakerSide)
            throw new Exception("Taker pubkey was changed");

        await BuildSideSwap1(swap.SwapTaker, swap.SwapMaker.RecoveryLockTime.Value.AddHours(-24));


        await PostSwap(swap);

        await this.RefreshSwap();

        await this.BlockchainApiService.Broadcast(swap.SwapTaker.CoinSymbol, swap.SwapTaker.SwapTransactionHex);
    }

    private async Task BuildSideSwap1(SwapSessionCoin swapSessionCoin, DateTime recoveryLockTime)
    {
        ExtKey.UseBCForHMACSHA512 = true;
        NBitcoin.Crypto.Hashes.UseBCForHMACSHA512 = true;

        Networks.Network network = SwapsConfiguration.Networks[swapSessionCoin.CoinSymbol];

        swapSessionCoin.RecoveryLockTime = recoveryLockTime;

        var account = _walletAccounts.GetAccountByKey(swapSessionCoin.SenderPubkey);

        RedeemType redeemType = account.AccountPurpose == 44 ? RedeemType.P2SH :
            account.AccountPurpose == 84 ? RedeemType.WitnessV0 : RedeemType.P2SH;

        var swapAddressContext = SwapBuilder.CreateSwapAddress(network,
            uint160.Parse(swap.SharedSecretHash),
            new PubKey(swapSessionCoin.SenderPubkey),
            new PubKey(swapSessionCoin.ReceiverPubkey),
            swapSessionCoin.RecoveryLockTime.Value,
            redeemType);

        swapSessionCoin.SwapRedeemScriptHex = swapAddressContext.RedeemScript.ToHex();
        swapSessionCoin.SwapAddress = swapAddressContext.SwapAddress;

        BlockcoreWalletSendFunds sendTo = new()
            {
                network = swapSessionCoin.CoinSymbol,
                feeRate = "medium",
                recipients = new()
            {
                new()
                {
                    hint = "swap address",
                    address = swapSessionCoin.SwapAddress,
                    amount = swapSessionCoin.Amount + swapSessionCoin.NetworkFee,
                }
            }
            };

        var trxContext = await WalletService.SendCoins(sendTo);

        swapSessionCoin.SwapTransactionHash = trxContext.transactionId;
        swapSessionCoin.SwapTransactionHex = trxContext.transactionHex;

        if (trxContext.transactionId == null || trxContext.transactionHex == null)
        {
            error = "transactionId was null, something went wrong";
            await SnackbarService.ShowMessage(error, Defaults.Classes.Position.BottomEnd, Severity.Error);
            Logger.LogWarning("trxid was null");
            Logger.LogWarning("trxhex=" + trxContext.transactionHex);
        }
    }

    //private async Task BuildSideSwap(SwapSessionCoin swapSessionCoin, DateTime recoveryLockTime)
    //{
    //    ExtKey.UseBCForHMACSHA512 = true;
    //    NBitcoin.Crypto.Hashes.UseBCForHMACSHA512 = true;

    //    Networks.Network network = SwapsConfiguration.Networks[swapSessionCoin.CoinSymbol];

    //    swapSessionCoin.RecoveryLockTime = recoveryLockTime;

    //    // refresh the account balances
    //    var walletConnectInput = new WalletConnectInput { WalletAccounts = _walletAccounts };
    //    var errorRes = await WalletService.ConnectWallet(walletConnectInput);
    //    errorRes.ThorwIfError();

    //    var account = _walletAccounts.GetAccount(network.CoinTicker);
    //    var walletAccount = walletConnectInput.WalletApiMessage.response.accounts.First(a => a.networkType == network.CoinTicker);

    //    var fee = network.MinRelayTxFee * 3;
    //    if (!SwapsConfiguration.FindInputs1(network, storage, swapSessionCoin.Amount, fee, walletConnectInput, out List<UtxoData> balancesList))
    //    {
    //        error = "not enough balance";
    //        return;
    //    }

    //    //var utxos = SwapsConfiguration.AddPrivateKeys(network, storage, balancesList);
    //    var utxos = SwapsConfiguration.ConvertToUtxo(network, balancesList); ;

    //    PubKey pubKey = SwapsConfiguration.GetNextAvailableAddress(network, storage);

    //    //RedeemType redeemType = HdOperations.GetPurpose(accountInfo.Path) == 44 ? RedeemType.P2SH :
    //    //    HdOperations.GetPurpose(accountInfo.Path) == 88 ? RedeemType.WitnessV0 : RedeemType.P2SH;

    //    RedeemType redeemType = walletAccount.purpose == 44 ? RedeemType.P2SH :
    //        walletAccount.purpose == 88 ? RedeemType.WitnessV0 : RedeemType.P2SH;

    //    var change = redeemType == RedeemType.P2SH ?
    //        pubKey.GetAddress(network).ScriptPubKey :
    //        pubKey.GetSegwitAddress(network).ScriptPubKey;

    //    var transactionContext = SwapBuilder.CreateSwapTransaction(network,
    //        uint160.Parse(swap.SharedSecretHash),
    //        new PubKey(swapSessionCoin.SenderPubkey),
    //        change,
    //        new PubKey(swapSessionCoin.ReceiverPubkey),
    //        swapSessionCoin.RecoveryLockTime.Value,
    //        swapSessionCoin.Amount,
    //        utxos,
    //        new FeeRate(new Money(fee)),
    //        redeemType);

    //    swapSessionCoin.SwapTransactionHex = transactionContext.Transaction.ToHex(network.Consensus.ConsensusFactory);
    //    swapSessionCoin.SwapTransactionHash = transactionContext.Transaction.GetHash().ToString();
    //    swapSessionCoin.SwapRedeemScriptHex = transactionContext.RedeemScript.ToHex();
    //    swapSessionCoin.SwapAddress = transactionContext.SwapAddress;
    //}

    private async Task RefreshSwap()
    {
        swap = await Http.GetFromJsonAsync<SwapSession>($"api/SwapCoordinator/session/{swapSession}");

        var myswaps = storage.GetSwaps();
        if (myswaps != null)
        {
            var swapStore = myswaps.FirstOrDefault(s => s.SwapSessionId == swap.SwapSessionId);
            if (swapStore != null)
            {
                myswaps.Remove(swapStore);
                myswaps.Add(swap);
                storage.SetSwaps(myswaps);
            }
        }
    }

    private async Task PostSwap(SwapSession swap)
    {
        await Http.PostAsJsonAsync($"api/SwapCoordinator/update", swap);

        var myswaps = storage.GetSwaps();
        var swapStore = myswaps.FirstOrDefault(s => s.SwapSessionId == swap.SwapSessionId);
        if (swapStore != null)
        {
            myswaps.Remove(swapStore);
            myswaps.Add(swap);
            storage.SetSwaps(myswaps);
        }
    }

    private async Task RefreshConfirmations()
    {
        if (swap?.SwapMaker.SwapTransactionHash != null)
        {
            MakerSwapTransactionConfirmations = await BlockchainApiService.GetConfirmationsAsync(
                swap.SwapMaker.CoinSymbol,
                swap.SwapMaker.SwapTransactionHash,
                swap.SwapMaker.SwapTransactionHex);
        }

        if (swap?.SwapTaker.SwapTransactionHash != null)
        {
            TakerSwapTransactionConfirmations = await BlockchainApiService.GetConfirmationsAsync(
                swap.SwapTaker.CoinSymbol,
                swap.SwapTaker.SwapTransactionHash,
                swap?.SwapTaker.SwapTransactionHex);
        }

        if (swap?.SwapTaker.ExchangeTransactionHex != null)
        {
            MakerExchangeTransactionConfirmations = await BlockchainApiService.GetConfirmationsAsync(
                swap.SwapTaker.CoinSymbol,
                swap.SwapTaker.ExchangeTransactionHash,
                swap?.SwapTaker.ExchangeTransactionHex);
        }

        if (swap?.SwapMaker.ExchangeTransactionHex != null)
        {
            TakerExchangeTransactionConfirmations = await BlockchainApiService.GetConfirmationsAsync(
                swap.SwapMaker.CoinSymbol,
                swap.SwapMaker.ExchangeTransactionHash,
                swap?.SwapMaker.ExchangeTransactionHex);
        }
    }

    //private async Task MakerExchangeFunds()
    //{
    //    ExtKey.UseBCForHMACSHA512 = true;
    //    NBitcoin.Crypto.Hashes.UseBCForHMACSHA512 = true;

    //    if (swap.SwapTaker.ReceiverPubkey != mypubkeyTakerSide)
    //        throw new Exception("Maker pubkey was changed");

    //    Networks.Network network = SwapsConfiguration.Networks[swap.SwapTaker.CoinSymbol];

    //    var account = _walletAccounts.GetAccount(swap.SwapMaker.CoinSymbol);
    //    var (errorOut, sharedSecret, sharedSecretHash) = await WalletService.GenerateSecretHash(account, swap.SwapSessionId);
    //    if (!string.IsNullOrEmpty(errorOut))
    //    {
    //        error = errorOut;
    //        return;
    //    }

    //    var extendedKey = ExtKey.Parse(storage.GetWalletPrivkey(), network);

    //    ExchangeSwapFund(swap.SwapTaker, sharedSecret, extendedKey.PrivateKey);

    //    await PostSwap(swap);

    //    await this.RefreshSwap();

    //    await this.BlockchainApiService.Broadcast(swap.SwapTaker.CoinSymbol, swap.SwapTaker.ExchangeTransactionHex);
    //}

    //private async Task TakerExchangeFunds()
    //{
    //    ExtKey.UseBCForHMACSHA512 = true;
    //    NBitcoin.Crypto.Hashes.UseBCForHMACSHA512 = true;

    //    if (swap.SwapMaker.ReceiverPubkey != mypubkeyMakerSide)
    //        throw new Exception("Taker pubkey was changed");

    //    if (string.IsNullOrEmpty(this.SharedSecret))
    //        throw new Exception("Missing shared secret");

    //    var walletWrods = storage.GetWalletWords();
    //    var extendedKey = HdOperations.GetExtendedKey(walletWrods);

    //    ExchangeSwapFund(swap.SwapMaker, new uint256(this.SharedSecret), extendedKey.PrivateKey);

    //    swap.Status = SwapsDataStatus.Complete;

    //    await PostSwap(swap);

    //    await this.RefreshSwap();

    //    await this.BlockchainApiService.Broadcast(swap.SwapMaker.CoinSymbol, swap.SwapMaker.ExchangeTransactionHex);
    //}

    //private void ExchangeSwapFund(SwapSessionCoin swapSessionCoin, uint256 sharedSecret, Key privateKey)
    //{
    //   Networks.Network network = SwapsConfiguration.Networks[swapSessionCoin.CoinSymbol];

    //    var transaciton = network.Consensus.ConsensusFactory.CreateTransaction(swapSessionCoin.SwapTransactionHex);
    //    var redeemScript = Script.FromHex(swapSessionCoin.SwapRedeemScriptHex);

    //    long fee = network.MinRelayTxFee * 3;

    //    PubKey pubKey = SwapsConfiguration.GetNextAvailableAddress(network, storage);

    //    var exchangeTransaction = SwapBuilder.CreateSwapSpendTransaction(
    //        network,
    //        transaciton,
    //        redeemScript,
    //        sharedSecret,
    //        pubKey.GetAddress(network).ScriptPubKey,
    //        privateKey,
    //        new FeeRate(new Money(fee)));

    //    swapSessionCoin.ExchangeTransactionHex = exchangeTransaction.ToHex(network.Consensus.ConsensusFactory);
    //    swapSessionCoin.ExchangeTransactionHash = exchangeTransaction.GetHash().ToString();
    //}

    private async Task MakerExchangeFunds1()
    {
        ExtKey.UseBCForHMACSHA512 = true;
        NBitcoin.Crypto.Hashes.UseBCForHMACSHA512 = true;

        if (swap.SwapTaker.ReceiverPubkey != mypubkeyTakerSide)
            throw new Exception("Maker pubkey was changed");

        Networks.Network network = SwapsConfiguration.Networks[swap.SwapTaker.CoinSymbol];

        var account = _walletAccounts.GetAccountByKey(swap.SwapMaker.SenderPubkey);
        var (errorOut, sharedSecret, sharedSecretHash) = await WalletService.GenerateSecretHash(account, swap.SwapSessionId);
        if (!string.IsNullOrEmpty(errorOut))
        {
            error = errorOut;
            await SnackbarService.ShowMessage(error, Defaults.Classes.Position.BottomEnd, Severity.Error);

            return;
        }

        if (sharedSecretHash == null || sharedSecretHash.ToString() != swap.SharedSecretHash)
        {
            throw new Exception("Secret hash was not generated correctly");
        }

        var walletConnecet = new WalletConnectInput { WalletAccounts = _walletAccounts };
        var errorRes = await WalletService.ConnectWallet(walletConnecet);
        if (!string.IsNullOrEmpty(errorRes))
        {
            error = errorRes;
            await SnackbarService.ShowMessage(error, Defaults.Classes.Position.BottomEnd, Severity.Error);
            return;
        }

        account = _walletAccounts.GetAccountByKey(swap.SwapTaker.ReceiverPubkey);

        var address = SwapsConfiguration.GetNextAvailableAddress1(walletConnecet, account);

        await ExchangeSwapFund1(swap.SwapTaker, sharedSecret, address, account);

        swap.Status = SwapsDataStatus.Complete;

        await PostSwap(swap);

        await this.RefreshSwap();

        await this.BlockchainApiService.Broadcast(swap.SwapTaker.CoinSymbol, swap.SwapTaker.ExchangeTransactionHex);
    }

    private async Task TakerExchangeFunds1()
    {
        ExtKey.UseBCForHMACSHA512 = true;
        NBitcoin.Crypto.Hashes.UseBCForHMACSHA512 = true;

        if (swap.SwapMaker.ReceiverPubkey != mypubkeyMakerSide)
            throw new Exception("Taker pubkey was changed");

        if (string.IsNullOrEmpty(this.SharedSecret))
            throw new Exception("Missing shared secret");

        Networks.Network network = SwapsConfiguration.Networks[swap.SwapMaker.CoinSymbol];

        var walletConnecet = new WalletConnectInput { WalletAccounts = _walletAccounts };
        var errorRes = await WalletService.ConnectWallet(walletConnecet);
        if (!string.IsNullOrEmpty(errorRes))
        {
            error = errorRes;
            await SnackbarService.ShowMessage(error, Defaults.Classes.Position.BottomEnd, Severity.Error);
            return;
        }

        var account = _walletAccounts.GetAccountByKey(swap.SwapMaker.ReceiverPubkey);

        var address = SwapsConfiguration.GetNextAvailableAddress1(walletConnecet, account);

        await ExchangeSwapFund1(swap.SwapMaker, new uint256(this.SharedSecret), address, account);

        swap.Status = SwapsDataStatus.Complete;

        await PostSwap(swap);

        await this.RefreshSwap();

        await this.BlockchainApiService.Broadcast(swap.SwapMaker.CoinSymbol, swap.SwapMaker.ExchangeTransactionHex);
    }

    private async Task ExchangeSwapFund1(SwapSessionCoin swapSessionCoin, uint256 sharedSecret, string sendToAddress, WalletAccount account)
    {
        //if (mypubkeyTakerSide != swapSessionCoin.ReceiverPubkey)
        //    throw new Exception("Invalid key");

        Networks.Network network = SwapsConfiguration.Networks[swapSessionCoin.CoinSymbol];

        var transaciton = network.Consensus.ConsensusFactory.CreateTransaction(swapSessionCoin.SwapTransactionHex);
        var redeemScript = Script.FromHex(swapSessionCoin.SwapRedeemScriptHex);

        var unsignedExchangeTransaction = SwapBuilder.CreateSwapSpendUnsignedTransaction(
            network,
            transaciton,
            sendToAddress,
            new Money(swapSessionCoin.NetworkFee));

        var swapCoinsInput = new BlockcoreWalletSwapCoins
            {
                walletId = account.WalletId,
                accountId = account.AccountId,
                network = network.CoinTicker,
                swapTrxHex = swapSessionCoin.SwapTransactionHex,
                redeemScriptHex = swapSessionCoin.SwapRedeemScriptHex,
                secretHashHex = Encoders.Hex.EncodeData(sharedSecret.ToBytes()),
                trxToSignHex = unsignedExchangeTransaction.ToHex(network.Consensus.ConsensusFactory),
                message = $"Swap {Money.Satoshis(swapSessionCoin.Amount)} {swapSessionCoin.CoinSymbol} to {sendToAddress}"
            };

        var result = await WalletService.SwapCoins(swapCoinsInput);

        if (result == null)
            throw new Exception("Failed to call SwapCoins api method on the wallet");

        if (string.IsNullOrEmpty(result.transactionId))
        {
            if (string.IsNullOrEmpty(result.privateKey))
                throw new Exception("Private key was not provided by wallet");

            var privkey = new Key(Encoders.Hex.DecodeData(result.privateKey));

            var exchangeTransaction = SwapBuilder.SignSwapSpendUnsignedTransaction(
                network,
                transaciton,
                unsignedExchangeTransaction,
                redeemScript,
                sharedSecret,
                privkey);

            swapSessionCoin.ExchangeTransactionHex = exchangeTransaction.ToHex(network.Consensus.ConsensusFactory);
            swapSessionCoin.ExchangeTransactionHash = exchangeTransaction.GetHash().ToString();
        }
        else
        {
            swapSessionCoin.ExchangeTransactionHex = result.transactionHex;
            swapSessionCoin.ExchangeTransactionHash = result.transactionId;
        }
    }

    private async Task ScanForSecretHash()
    {
        Networks.Network network = SwapsConfiguration.Networks[swap.SwapTaker.CoinSymbol];

        if (swap.SwapTaker.ExchangeTransactionHex != null)
        {
            var transaciton = network.Consensus.ConsensusFactory.CreateTransaction(swap.SwapTaker.ExchangeTransactionHex);

            var secret = SwapScripts.GetSecretFromScriptSig(transaciton);

            this.SharedSecret = secret.ToString();
            return;
        }

        try
        {
            var indexer = await storage.Indexer(swap.SwapTaker.CoinSymbol);
            var url = $"/query/transaction/{swap.SwapTaker.SwapTransactionHash}";
            var res = await Http.GetFromJsonAsync<TransactionData>(indexer.Url + url);
            foreach (var output in res.outputs)
            {
                if (output.address == swap.SwapTaker.SwapAddress)
                {
                    if (!string.IsNullOrEmpty(output.spentInTransaction))
                    {
                        url = $"/query/transaction/{output.spentInTransaction}/hex";
                        var trxHex = await Http.GetStringAsync(indexer.Url + url);

                        if (res != null)
                        {
                            swap.SwapTaker.ExchangeTransactionHex = trxHex; // the other side didn't tell us they spent the coins

                            var exchangeTransaciton = network.Consensus.ConsensusFactory.CreateTransaction(trxHex);

                            var secret = SwapScripts.GetSecretFromScriptSig(exchangeTransaciton);

                            this.SharedSecret = secret.ToString();
                        }
                    }
                }
            }

        }
        catch (Exception ex)
        {
            error = ex.Message;
            await SnackbarService.ShowMessage(error, Defaults.Classes.Position.BottomEnd, Severity.Error);
        }
    }

    //private async Task MakerRecoverFunds()
    //{
    //    ExtKey.UseBCForHMACSHA512 = true;
    //    NBitcoin.Crypto.Hashes.UseBCForHMACSHA512 = true;

    //    if (swap.SwapMaker.SenderPubkey != mypubkeyMakerSide)
    //        throw new Exception("Taker pubkey was changed");

    //    var walletWrods = storage.GetWalletWords();
    //    var extendedKey = HdOperations.GetExtendedKey(walletWrods);

    //    RecoverFunds(swap.SwapMaker, extendedKey.PrivateKey);

    //    await PostSwap(swap);

    //    await this.RefreshSwap();

    //    await this.BlockchainApiService.Broadcast(swap.SwapMaker.CoinSymbol, swap.SwapMaker.RecoveryTransactionHex);
    //}

    //private async Task TakerRecoverFunds()
    //{
    //    ExtKey.UseBCForHMACSHA512 = true;
    //    NBitcoin.Crypto.Hashes.UseBCForHMACSHA512 = true;

    //    if (swap.SwapTaker.SenderPubkey != mypubkeyTakerSide)
    //        throw new Exception("Taker pubkey was changed");

    //    var walletWrods = storage.GetWalletWords();
    //    var extendedKey = HdOperations.GetExtendedKey(walletWrods);

    //    RecoverFunds(swap.SwapTaker, extendedKey.PrivateKey);

    //    await PostSwap(swap);

    //    await this.RefreshSwap();

    //    await this.BlockchainApiService.Broadcast(swap.SwapTaker.CoinSymbol, swap.SwapTaker.RecoveryTransactionHex);
    //}

    //private void RecoverFunds(SwapSessionCoin swapSessionCoin, Key privateKey)
    //{
    //    //if (mypubkey != swapSessionCoin.SenderPubkey)
    //    //    throw new Exception("Invalid key");

    //    Networks.Network network = SwapsConfiguration.Networks[swapSessionCoin.CoinSymbol];

    //    var transaciton = network.Consensus.ConsensusFactory.CreateTransaction(swapSessionCoin.SwapTransactionHex);
    //    var redeemScript = Script.FromHex(swapSessionCoin.SwapRedeemScriptHex);

    //    long fee = network.MinRelayTxFee * 3;

    //    PubKey pubKey = SwapsConfiguration.GetNextAvailableAddress(network, storage);

    //    var recoveryTransaction = SwapBuilder.CreateSwapRecoveryTransaction(
    //        network,
    //        transaciton,
    //        redeemScript,
    //        pubKey.GetAddress(network).ScriptPubKey,
    //        privateKey,
    //        new FeeRate(new Money(fee)),
    //        swapSessionCoin.RecoveryLockTime!.Value);

    //    swapSessionCoin.RecoveryTransactionHex = recoveryTransaction.ToHex(network.Consensus.ConsensusFactory);
    //    swapSessionCoin.RecoveryTransactionHash = recoveryTransaction.GetHash().ToString();
    //}

    private async Task MakerRecoverFunds1()
    {
        ExtKey.UseBCForHMACSHA512 = true;
        NBitcoin.Crypto.Hashes.UseBCForHMACSHA512 = true;

        if (swap.SwapMaker.SenderPubkey != mypubkeyMakerSide)
            throw new Exception("Maker pubkey was changed");

        Networks.Network network = SwapsConfiguration.Networks[swap.SwapMaker.CoinSymbol];

        var walletConnecet = new WalletConnectInput { WalletAccounts = _walletAccounts };
        var errorRes = await WalletService.ConnectWallet(walletConnecet);
        if (!string.IsNullOrEmpty(errorRes))
        {
            error = errorRes;
            await SnackbarService.ShowMessage(error, Defaults.Classes.Position.BottomEnd, Severity.Error);
            return;
        }

        var account = _walletAccounts.GetAccountByKey(swap.SwapMaker.SenderPubkey);

        var address = SwapsConfiguration.GetNextAvailableAddress1(walletConnecet, account);

        await RecoverFunds1(swap.SwapMaker, address, account);

        swap.Status = SwapsDataStatus.Complete;

        await PostSwap(swap);

        await this.RefreshSwap();

        await this.BlockchainApiService.Broadcast(swap.SwapMaker.CoinSymbol, swap.SwapMaker.RecoveryTransactionHex);
    }

    private async Task TakerRecoverFunds1()
    {
        ExtKey.UseBCForHMACSHA512 = true;
        NBitcoin.Crypto.Hashes.UseBCForHMACSHA512 = true;

        if (swap.SwapTaker.SenderPubkey != mypubkeyTakerSide)
            throw new Exception("Taker pubkey was changed");

        Networks.Network network = SwapsConfiguration.Networks[swap.SwapTaker.CoinSymbol];

        var walletConnecet = new WalletConnectInput { WalletAccounts = _walletAccounts };
        var errorRes = await WalletService.ConnectWallet(walletConnecet);
        if (!string.IsNullOrEmpty(errorRes))
        {
            error = errorRes;
            await SnackbarService.ShowMessage(error, Defaults.Classes.Position.BottomEnd, Severity.Error);
            return;
        }

        var account = _walletAccounts.GetAccountByKey(swap.SwapTaker.SenderPubkey);

        var address = SwapsConfiguration.GetNextAvailableAddress1(walletConnecet, account);

        await RecoverFunds1(swap.SwapTaker, address, account);

        swap.Status = SwapsDataStatus.Complete;

        await PostSwap(swap);

        await this.RefreshSwap();

        await this.BlockchainApiService.Broadcast(swap.SwapTaker.CoinSymbol, swap.SwapTaker.RecoveryTransactionHex);
    }

    private async Task RecoverFunds1(SwapSessionCoin swapSessionCoin, string sendToAddress, WalletAccount account)
    {
        //if (mypubkey != swapSessionCoin.SenderPubkey)
        //    throw new Exception("Invalid key");

        Networks.Network network = SwapsConfiguration.Networks[swapSessionCoin.CoinSymbol];

        var transaciton = network.Consensus.ConsensusFactory.CreateTransaction(swapSessionCoin.SwapTransactionHex);
        var redeemScript = Script.FromHex(swapSessionCoin.SwapRedeemScriptHex);

        var unsignedRecoverTransaction = SwapBuilder.CreateSwapRecoveryUnsignedTransaction(
            network,
            transaciton,
            sendToAddress,
            new Money(swapSessionCoin.NetworkFee),
            swapSessionCoin.RecoveryLockTime!.Value);

        var swapCoinsInput = new BlockcoreWalletSwapCoins
            {
                walletId = account.WalletId,
                accountId = account.AccountId,
                network = network.CoinTicker,
                swapTrxHex = swapSessionCoin.SwapTransactionHex,
                redeemScriptHex = swapSessionCoin.SwapRedeemScriptHex,
                secretHashHex = null, // this means it is recover not swap
                trxToSignHex = unsignedRecoverTransaction.ToHex(network.Consensus.ConsensusFactory),
                message = $"Recover {Money.Satoshis(swapSessionCoin.Amount)} {swapSessionCoin.CoinSymbol} to {sendToAddress}"
            };

        var result = await WalletService.SwapCoins(swapCoinsInput);

        if (result == null)
            throw new Exception("Failed to call SwapCoins api method on the wallet");

        if (string.IsNullOrEmpty(result.transactionId))
        {
            if (string.IsNullOrEmpty(result.privateKey))
                throw new Exception("Private key was not provided by wallet");

            var privkey = new Key(Encoders.Hex.DecodeData(result.privateKey));

            var recoveryTransaction = SwapBuilder.SignSwapRecoveryUnsignedTransaction(
                network,
                transaciton,
                unsignedRecoverTransaction,
                redeemScript,
                privkey);

            swapSessionCoin.RecoveryTransactionHex = recoveryTransaction.ToHex(network.Consensus.ConsensusFactory);
            swapSessionCoin.RecoveryTransactionHash = recoveryTransaction.GetHash().ToString();
        }
        else
        {
            swapSessionCoin.RecoveryTransactionHex = result.transactionHex;
            swapSessionCoin.RecoveryTransactionHash = result.transactionId;
        }
    }

    bool ShowScriptMakerFlag = true;
    private void ShowScriptMaker()
    {
        ShowScriptMakerFlag = !ShowScriptMakerFlag;
    }

    bool ShowScriptTakerFlag = true;
    private void ShowScriptTaker()
    {
        ShowScriptTakerFlag = !ShowScriptTakerFlag;
    }
}
