@page "/viewswap/{swapsession}"
@using Blockcore.AtomicSwaps.Shared
@using Blockcore.Consensus.ScriptInfo
@using NBitcoin
@using System.Text.Json
@using Blockcore.AtomicSwaps.BlockcoreWallet
@using Blockcore.AtomicSwaps.BlockcoreWallet.Exceptions
@using Blockcore.AtomicSwaps.Client.Services
@using Blockcore.Utilities
@using NBitcoin.DataEncoders
@using JsonSerializer = System.Text.Json.JsonSerializer
@inject HttpClient Http
@inject Storage storage;
@inject SwapsConfiguration SwapsConfiguration;
@inject NavigationManager NavigationManager;
@inject ILogger<ViewSwap> Logger;
@inject IBlockcoreWalletConnector WalletConnector
@inject IBlockchainApiService BlockchainApiService;
@inject IWalletService WalletService

<PageTitle>View Swaps</PageTitle>

<h1>View Swaps</h1>

<p>This component displays a swap.</p>

<p class="alert-danger">@error</p>

@if (swap != null)
{
    @*=========================Swap info========================*@

    <h4>Session id - @swap.SwapSessionId</h4>
    <p>Created - @swap.Created</p>
    <p>Status - @swap.Status</p>

    <h4>Swap @Money.Satoshis(swap.SwapMaker.Amount) @swap.SwapMaker.CoinSymbol for @Money.Satoshis(swap.SwapTaker.Amount) @swap.SwapTaker.CoinSymbol</h4>

    @if (mypubkeyBuyerSide == null && mypubkeySellerSide == null){<p><strong>Not my swap</strong></p>}
    else if (swap.SwapMaker.SenderPubkey == mypubkeySellerSide){<p class="text-success"><strong> I am the seller</strong></p>}
    else if (swap.SwapTaker.SenderPubkey == mypubkeyBuyerSide){<p class="text-success"><strong>I am the buyer</strong></p>}
    else{<p><strong>Not my swap</strong></p>}

    <button class="btn btn-primary" @onclick="RefreshSwap">Refresh Swap</button>

    @if (swap.SwapMaker.SwapTransactionHash != null || swap.SwapTaker.SwapTransactionHash != null)
    {
        <button class="btn btn-primary ms-2" @onclick="RefreshConfirmations">Refresh confirmations</button>
    }
    <hr/>

    @*=========================Step1 - swap created by seller ========================*@

    <h3>Step 1 - swap created by the seller</h3>

    <p>Seller Pubkey - @swap.SwapMaker.SenderPubkey</p>
    <p>Shared secret hash - @swap.SharedSecretHash</p>
    
    @if (swap.SwapMaker.SenderPubkey == mypubkeySellerSide && swap.SwapTaker.SenderPubkey == null)
    {
        <button class="btn btn-danger" @onclick="DeleteSwap">Delete Swap</button>
    }

    <hr />

    @*=========================Step2 - swap locked by buyer ========================*@

    <h3>Step 2 - swap locked by buyer</h3>
    
    <p>Buyer Pubkey - @swap.SwapTaker.SenderPubkey</p>

    @if (swap.SwapMaker.SenderPubkey != mypubkeySellerSide && swap.SwapTaker.SenderPubkey == null)
    {
        if (hasWallet)
        {
            if (_walletAccounts.Connected)
            {
                <button class="btn btn-success" @onclick="BuyerTakeSwap">Claim This Swap</button>
            }
            else
            {
                <p><a href="/walletconnect">Connect a wallet to participate in this swap </a></p>
            }
        }
        else
        {
            <p>Not wallet found please install the wallet at blockcore.net to participate in this swap</p>
        }
    }

    <hr />

    @*=========================Step3 - seller creates swap trx ========================*@

    <h3>Step 3 - seller swaps</h3>

    <p><strong>Seller sends @Money.Satoshis(swap.SwapMaker.Amount + swap.SwapMaker.NetworkFee + swap.SwapMaker.ServiceFee) @swap.SwapMaker.CoinSymbol</strong></p>
    <p>Swap amount = @Money.Satoshis(swap.SwapMaker.Amount) @swap.SwapMaker.CoinSymbol</p>
    <p>Network fee = @Money.Satoshis(swap.SwapMaker.NetworkFee) @swap.SwapMaker.CoinSymbol</p>
    <p>Service fee = @Money.Satoshis(swap.SwapMaker.ServiceFee) @swap.SwapMaker.CoinSymbol</p>

    @if (swap.SwapMaker.SwapTransactionHash != null)
    {
        <p>seller swap chain @swap.SwapMaker.CoinSymbol trx id -  @swap.SwapMaker.SwapTransactionHash</p>
        <p>seller swap trx confirmations - @SellerSwapTransactionConfirmations</p>
        @if (swap.SwapMaker.RecoveryLockTime.HasValue)
        {
            <p>InProgress until : @swap.SwapMaker.RecoveryLockTime?.ToString("dd/MM/yyyy HH:mm:ss") (@((swap.SwapMaker.RecoveryLockTime - DateTime.UtcNow)?.TotalHours.ToString("F")) hours left)</p>
        }

        <p>Swap address:</p>
        <div class="alert alert-secondary" role="alert">
            @swap.SwapMaker.SwapAddress
        </div>

        <p>ScriptHash :</p>
        <div class="alert alert-info" role="alert">
            @Script.FromHex(@swap.SwapMaker.SwapRedeemScriptHex).ToString()
        </div>
    }

    @if (swap.SwapMaker.SenderPubkey == mypubkeySellerSide)
    {
        @if (swap.SwapTaker.SenderPubkey != null && swap.SwapMaker.SwapTransactionHash == null)
        {
            <button class="btn btn-info" @onclick="BuildSellerSwap">Build Seller Swap Transaction</button>
        }
    }

    <hr />

    @*=========================Step4 - buyer creates swap trx ========================*@

    <h3>Step 4 - buyer swaps</h3>

    <p><strong>Buyer sends @Money.Satoshis(swap.SwapTaker.Amount + swap.SwapTaker.NetworkFee + swap.SwapTaker.ServiceFee) @swap.SwapTaker.CoinSymbol</strong></p>
    <p>Swap amount = @Money.Satoshis(swap.SwapTaker.Amount) @swap.SwapTaker.CoinSymbol</p>
    <p>Network fee = @Money.Satoshis(swap.SwapTaker.NetworkFee) @swap.SwapTaker.CoinSymbol</p>
    <p>Service fee = @Money.Satoshis(swap.SwapTaker.ServiceFee) @swap.SwapTaker.CoinSymbol</p>

    @if (swap.SwapTaker.SwapTransactionHash != null)
    {
        <p>buyer swap chain @swap.SwapTaker.CoinSymbol trx id - @swap.SwapTaker.SwapTransactionHash</p>
        <p>buyer swap trx id confirmations : @BuyerSwapTransactionConfirmations</p>  
        @if (swap.SwapTaker.RecoveryLockTime.HasValue)
        {
            <p>InProgress until : @swap.SwapTaker.RecoveryLockTime?.ToString("dd/MM/yyyy HH:mm:ss") (@((swap.SwapTaker.RecoveryLockTime - DateTime.UtcNow)?.TotalHours.ToString("F")) hours left)</p>
        }    

        <p>Swap address:</p>
        <div class="alert alert-secondary" role="alert">
            @swap.SwapTaker.SwapAddress
        </div>

        <p>ScriptHash :</p>
        <div class="alert alert-info" role="alert">
            @Script.FromHex(@swap.SwapTaker.SwapRedeemScriptHex).ToString()
        </div>
    }

    @if (swap.SwapTaker.SenderPubkey == mypubkeyBuyerSide)
    {
        @if (swap.SwapMaker.SwapTransactionHash != null)
        {
            @if (SellerSwapTransactionConfirmations > 0 && swap.SwapTaker.SwapTransactionHash == null)
            {
                <button class="btn btn-info" @onclick="BuildBuyerSwap">Build Buyer Swap Transaction</button>
            }
        }
    }

    <hr />

    @*=========================Step5 - seller creates exchange trx (reveal secret) ========================*@

    <h3>Step 5 - seller claims coins (reveal secret)</h3>

    <p><strong>Seller receives @Money.Satoshis(swap.SwapTaker.Amount) @swap.SwapTaker.CoinSymbol</strong></p>

    @if (@swap.SwapTaker.ExchangeTransactionHash != null)
    {
        <p>Seller Exchange chain @swap.SwapTaker.CoinSymbol trx id - @swap.SwapTaker.ExchangeTransactionHash</p>
        <p>Seller Exchange trx Confirmations : @SellerExchangeTransactionConfirmations</p>

        <P class="text-success"><strong>SELLER EXCHANGE SUCCESS</strong></P>
    }

    @if (swap.SwapMaker.SenderPubkey == mypubkeySellerSide)
    {
        if (BuyerSwapTransactionConfirmations > 0 && swap.SwapTaker.SwapTransactionHash != null &&
            SellerSwapTransactionConfirmations > 0 && swap.SwapMaker.SwapTransactionHash != null)
        {
            if (swap.SwapTaker.ExchangeTransactionHash == null && swap.SwapMaker.RecoveryTransactionHash == null)
            {
                <button class="btn btn-success" @onclick="SellerExchangeFunds1">Claim Seller Coins</button>
            }
        }

        if (swap.SwapMaker.SwapTransactionHash != null && swap.SwapMaker.ExchangeTransactionHash == null && swap.SwapMaker.RecoveryLockTime < DateTime.UtcNow)
        {
            <br />

            <h4>Seller claims recover trx (timeout)</h4>

            <p><strong>Seller takes back @Money.Satoshis(swap.SwapMaker.Amount) @swap.SwapMaker.CoinSymbol</strong></p>

            if (swap.SwapMaker.RecoveryTransactionHash == null)
            {
                <button class="btn btn-danger" @onclick="SellerRecoverFunds1">Recover Seller Funds</button>
            }
            else
            {
                <P class="text-warning"><strong>SELLER RECOVER SUCCESS</strong></P>
            }
        }
    }
    
    <hr />

    @*=========================Step6 - buyer creates exchange trx (discover secret) ========================*@

    <h3>Step 6 - buyer claims coins (discover secret)</h3>

    <p><strong>Buyer receives @Money.Satoshis(swap.SwapMaker.Amount) @swap.SwapMaker.CoinSymbol</strong></p>

    @if (swap.SwapMaker.ExchangeTransactionHash != null)
    {
        <p>Buyer Exchange chain @swap.SwapMaker.CoinSymbol trx id - @swap.SwapMaker.ExchangeTransactionHash</p>
        <p>Buyer Exchange trx Confirmations : @BuyerExchangeTransactionConfirmations</p>

        <P class="text-success"><strong>BUYER EXCHANGE SUCCESS</strong></P>
    }
    
    @if (swap.SwapTaker.SenderPubkey == mypubkeyBuyerSide)
    {
        @if (BuyerSwapTransactionConfirmations > 0 && swap.SwapTaker.SwapTransactionHash != null &&
            SellerSwapTransactionConfirmations > 0 && swap.SwapMaker.SwapTransactionHash != null)
        {
            @if (swap.SwapMaker.ExchangeTransactionHash == null && swap.SwapTaker.RecoveryTransactionHash == null)
            {
                if (string.IsNullOrEmpty(SharedSecret))
                {
                    <button class="btn btn-warning" @onclick="ScanForSecretHash">Check the Blockchain for the secret hash</button>
                }
                else
                {
                    <button class="btn btn-success" @onclick="BuyerExchangeFunds1">Claim Buyer Swap Transaction</button>
                }
            }
        }

        if (swap.SwapTaker.SwapTransactionHash != null && swap.SwapTaker.ExchangeTransactionHash == null && swap.SwapTaker.RecoveryLockTime < DateTime.UtcNow)
        {
            <br/>

            <h4>Buyer claims recover trx (timeout)</h4>

            <p><strong>Buyer takes back @Money.Satoshis(swap.SwapTaker.Amount) @swap.SwapTaker.CoinSymbol</strong></p>

            if (swap.SwapTaker.RecoveryTransactionHash == null)
            {
                <button class="btn btn-danger" @onclick="BuyerRecoverFunds1">Recover Buyer Funds</button>
            }
            else
            {
                <P class="text-warning"><strong>BUYER RECOVER SUCCESS</strong></P>
            }
        }
    }

    <hr />
}

@code {
    private SwapSession? swap;

    string error;

    [Parameter]
    public string swapSession { get; set; }

    string SharedSecret { get; set; }

    string mypubkeySellerSide;
    string mypubkeyBuyerSide;

    int SellerSwapTransactionConfirmations;
    int BuyerSwapTransactionConfirmations;
    int SellerExchangeTransactionConfirmations;
    int BuyerExchangeTransactionConfirmations;
    int SellerRecoveryTransactionConfirmations;
    int BuyerRecoveryTransactionConfirmations;
   
    WalletAccounts _walletAccounts = new();

    private bool hasWallet;

    protected override async Task OnInitializedAsync()
    {
        hasWallet = await WalletConnector.HasBlockcoreWallet();
        _walletAccounts = storage.GetOrCreate<WalletAccounts>();

        string? swapRes = await Http.GetStringAsync($"api/SwapCoordinator/session/{swapSession}");

        if (string.IsNullOrEmpty(swapRes))
        {
            error = $"Swap not found!";
            return;
        }

        swap = JsonSerializer.Deserialize<SwapSession>(swapRes, new JsonSerializerOptions
        {
            PropertyNamingPolicy = JsonNamingPolicy.CamelCase,
            WriteIndented = true
        });

        if (swap != null)
        {
            Guard.NotNull(swap.SwapMaker, nameof(swap.SwapMaker));
            Guard.NotNull(swap.SwapTaker, nameof(swap.SwapTaker));

            // if I am the seller this is where my keys will be found
            if (swap.SwapMaker.SenderPubkey != null)
            {
                Guard.NotNull(swap.SwapTaker.ReceiverPubkey, nameof(swap.SwapTaker.ReceiverPubkey));

                var accountSellerSide = _walletAccounts.TryGetAccountByKey(swap.SwapMaker.SenderPubkey);
                mypubkeySellerSide = accountSellerSide?.Pubkey;

                var accountBuyerSide = _walletAccounts.TryGetAccountByKey(swap.SwapTaker.ReceiverPubkey);
                mypubkeyBuyerSide = accountBuyerSide?.Pubkey;
            }

            // if I am the buyer this is where my keys will be found   
            if (mypubkeySellerSide == null && swap.SwapTaker.SenderPubkey!= null)
            {
                Guard.NotNull(swap.SwapMaker.ReceiverPubkey, nameof(swap.SwapMaker.ReceiverPubkey));

                var accountSellerSide = _walletAccounts.TryGetAccountByKey(swap.SwapMaker.ReceiverPubkey);
                mypubkeySellerSide = accountSellerSide?.Pubkey;

                var accountBuyerSide = _walletAccounts.TryGetAccountByKey(swap.SwapTaker.SenderPubkey);
                mypubkeyBuyerSide = accountBuyerSide?.Pubkey;
            }
        }

        await this.RefreshConfirmations();
    }

    private async Task DeleteSwap()
    {
        // this method is of course problematic because anyone can delete using an api call
        // we need to add pubkey validation to each request to the api

        if (swap.SwapMaker.SenderPubkey == mypubkeySellerSide || swap.SwapTaker.SenderPubkey == mypubkeyBuyerSide)
        {
            await Http.DeleteAsync($"api/SwapCoordinator/delete/{swapSession}");
        }
        else
        {
            error = "Only the owner can delete a swap";
            return;
        }

        var swaps = storage.GetSwaps();
        if (swaps != null)
        {
            var myswap = swaps.FirstOrDefault(s => s.SwapSessionId == swapSession);
            if (myswap != null)
            {
                swaps.Remove(myswap);
                storage.SetSwaps(swaps);
            }
        }

        NavigationManager.NavigateTo($"/");
    }

    private async Task BuyerTakeSwap()
    {
        ExtKey.UseBCForHMACSHA512 = true;
        NBitcoin.Crypto.Hashes.UseBCForHMACSHA512 = true;

        Guard.Assert(mypubkeySellerSide == null);
        Guard.Assert(mypubkeyBuyerSide == null);
        
        var accountSeller = _walletAccounts.FindAccount(swap.SwapMaker.CoinSymbol);
        var accountBuyer = _walletAccounts.FindAccount(swap.SwapTaker.CoinSymbol);

        mypubkeyBuyerSide = accountBuyer.Pubkey;
        mypubkeySellerSide = accountSeller.Pubkey;

        swap.Status = SwapsDataStatus.InProgress;
        swap.SwapTaker.SenderPubkey = mypubkeyBuyerSide;
        swap.SwapMaker.ReceiverPubkey = mypubkeySellerSide;

        var myswaps = storage.GetSwaps();

        if (myswaps == null)
        {
            myswaps = new List<SwapSession>();
            storage.SetSwaps(myswaps);
        }

        await Http.PostAsJsonAsync($"api/SwapCoordinator/update", swap);

        myswaps.Add(swap);
        storage.SetSwaps(myswaps);
    }
    
    private async Task BuildSellerSwap()
    {
        if (swap.SwapMaker.SenderPubkey != mypubkeySellerSide)
            throw new Exception("seller pubkey was changed");

        await BuildSideSwap1(swap.SwapMaker, DateTime.UtcNow.AddHours(48));

        await PostSwap(swap);

        await this.RefreshSwap();

        await this.BlockchainApiService.Broadcast(swap.SwapMaker.CoinSymbol, swap.SwapMaker.SwapTransactionHex);
    }

    private async Task BuildBuyerSwap()
    {
        if (swap.SwapTaker.SenderPubkey != mypubkeyBuyerSide)
            throw new Exception("buyer pubkey was changed");

        await BuildSideSwap1(swap.SwapTaker, swap.SwapMaker.RecoveryLockTime.Value.AddHours(-24));


        await PostSwap(swap);

        await this.RefreshSwap();

        await this.BlockchainApiService.Broadcast(swap.SwapTaker.CoinSymbol, swap.SwapTaker.SwapTransactionHex);
    }

    private async Task BuildSideSwap1(SwapSessionCoin swapSessionCoin, DateTime recoveryLockTime)
    {
        ExtKey.UseBCForHMACSHA512 = true;
        NBitcoin.Crypto.Hashes.UseBCForHMACSHA512 = true;

        Networks.Network network = SwapsConfiguration.Networks[swapSessionCoin.CoinSymbol];

        swapSessionCoin.RecoveryLockTime = recoveryLockTime;
        
        var account = _walletAccounts.GetAccountByKey(swapSessionCoin.SenderPubkey);

        RedeemType redeemType = account.AccountPurpose == 44 ? RedeemType.P2SH :
            account.AccountPurpose == 84 ? RedeemType.WitnessV0 : RedeemType.P2SH;

        var swapAddressContext = SwapBuilder.CreateSwapAddress(network,
            uint160.Parse(swap.SharedSecretHash),
            new PubKey(swapSessionCoin.SenderPubkey),
            new PubKey(swapSessionCoin.ReceiverPubkey),
            swapSessionCoin.RecoveryLockTime.Value,
            redeemType);

        swapSessionCoin.SwapRedeemScriptHex = swapAddressContext.RedeemScript.ToHex();
        swapSessionCoin.SwapAddress = swapAddressContext.SwapAddress;

        BlockcoreWalletSendFunds sendTo = new()
        {
            network = swapSessionCoin.CoinSymbol,
            feeRate = "medium",
            recipients = new()
            {
                new()
                {
                    hint = "swap address",
                    address = swapSessionCoin.SwapAddress,
                    amount = swapSessionCoin.Amount + swapSessionCoin.NetworkFee,
                }
            }
        };

        var trxContext = await WalletService.SendCoins(sendTo);

        swapSessionCoin.SwapTransactionHash = trxContext.transactionId;
        swapSessionCoin.SwapTransactionHex = trxContext.transactionHex;

        if (trxContext.transactionId == null || trxContext.transactionHex == null)
        {
            error = "transactionId was null, something went wrong";
            Logger.LogWarning("trxid was null");
            Logger.LogWarning("trxhex=" + trxContext.transactionHex);
        }
    }

    //private async Task BuildSideSwap(SwapSessionCoin swapSessionCoin, DateTime recoveryLockTime)
    //{
    //    ExtKey.UseBCForHMACSHA512 = true;
    //    NBitcoin.Crypto.Hashes.UseBCForHMACSHA512 = true;

    //    Networks.Network network = SwapsConfiguration.Networks[swapSessionCoin.CoinSymbol];

    //    swapSessionCoin.RecoveryLockTime = recoveryLockTime;

    //    // refresh the account balances
    //    var walletConnectInput = new WalletConnectInput { WalletAccounts = _walletAccounts };
    //    var errorRes = await WalletService.ConnectWallet(walletConnectInput);
    //    errorRes.ThorwIfError();

    //    var account = _walletAccounts.GetAccount(network.CoinTicker);
    //    var walletAccount = walletConnectInput.WalletApiMessage.response.accounts.First(a => a.networkType == network.CoinTicker);

    //    var fee = network.MinRelayTxFee * 3;
    //    if (!SwapsConfiguration.FindInputs1(network, storage, swapSessionCoin.Amount, fee, walletConnectInput, out List<UtxoData> balancesList))
    //    {
    //        error = "not enough balance";
    //        return;
    //    }

    //    //var utxos = SwapsConfiguration.AddPrivateKeys(network, storage, balancesList);
    //    var utxos = SwapsConfiguration.ConvertToUtxo(network, balancesList); ;

    //    PubKey pubKey = SwapsConfiguration.GetNextAvailableAddress(network, storage);

    //    //RedeemType redeemType = HdOperations.GetPurpose(accountInfo.Path) == 44 ? RedeemType.P2SH :
    //    //    HdOperations.GetPurpose(accountInfo.Path) == 88 ? RedeemType.WitnessV0 : RedeemType.P2SH;

    //    RedeemType redeemType = walletAccount.purpose == 44 ? RedeemType.P2SH :
    //        walletAccount.purpose == 88 ? RedeemType.WitnessV0 : RedeemType.P2SH;

    //    var change = redeemType == RedeemType.P2SH ? 
    //        pubKey.GetAddress(network).ScriptPubKey : 
    //        pubKey.GetSegwitAddress(network).ScriptPubKey;

    //    var transactionContext = SwapBuilder.CreateSwapTransaction(network,
    //        uint160.Parse(swap.SharedSecretHash),
    //        new PubKey(swapSessionCoin.SenderPubkey),
    //        change,
    //        new PubKey(swapSessionCoin.ReceiverPubkey),
    //        swapSessionCoin.RecoveryLockTime.Value, 
    //        swapSessionCoin.Amount, 
    //        utxos, 
    //        new FeeRate(new Money(fee)),
    //        redeemType);

    //    swapSessionCoin.SwapTransactionHex = transactionContext.Transaction.ToHex(network.Consensus.ConsensusFactory);
    //    swapSessionCoin.SwapTransactionHash = transactionContext.Transaction.GetHash().ToString();
    //    swapSessionCoin.SwapRedeemScriptHex = transactionContext.RedeemScript.ToHex();
    //    swapSessionCoin.SwapAddress = transactionContext.SwapAddress;
    //}

    private async Task RefreshSwap()
    {
        swap = await Http.GetFromJsonAsync<SwapSession>($"api/SwapCoordinator/session/{swapSession}");

        var myswaps = storage.GetSwaps();
        if (myswaps != null)
        {
            var swapStore = myswaps.FirstOrDefault(s => s.SwapSessionId == swap.SwapSessionId);
            if (swapStore != null)
            {
                myswaps.Remove(swapStore);
                myswaps.Add(swap);
                storage.SetSwaps(myswaps);
            }
        }
    }

    private async Task PostSwap(SwapSession swap)
    {
        await Http.PostAsJsonAsync($"api/SwapCoordinator/update", swap);

        var myswaps = storage.GetSwaps();
        var swapStore = myswaps.FirstOrDefault(s => s.SwapSessionId == swap.SwapSessionId);
        if (swapStore != null)
        {
            myswaps.Remove(swapStore);
            myswaps.Add(swap);
            storage.SetSwaps(myswaps);
        }
    }

    private async Task RefreshConfirmations()
    {
        if (swap?.SwapMaker.SwapTransactionHash != null)
        {
            SellerSwapTransactionConfirmations = await BlockchainApiService.GetConfirmationsAsync(
                swap.SwapMaker.CoinSymbol, 
                swap.SwapMaker.SwapTransactionHash, 
                swap.SwapMaker.SwapTransactionHex);
        }

        if (swap?.SwapTaker.SwapTransactionHash != null)
        {
            BuyerSwapTransactionConfirmations = await BlockchainApiService.GetConfirmationsAsync(
                swap.SwapTaker.CoinSymbol,
                swap.SwapTaker.SwapTransactionHash,
                swap?.SwapTaker.SwapTransactionHex);
        }

        if (swap?.SwapTaker.ExchangeTransactionHex != null)
        {
            SellerExchangeTransactionConfirmations = await BlockchainApiService.GetConfirmationsAsync(
                swap.SwapTaker.CoinSymbol,
                swap.SwapTaker.ExchangeTransactionHash,
                swap?.SwapTaker.ExchangeTransactionHex);
        }

        if (swap?.SwapMaker.ExchangeTransactionHex != null)
        {
            BuyerExchangeTransactionConfirmations = await BlockchainApiService.GetConfirmationsAsync(
                swap.SwapMaker.CoinSymbol,
                swap.SwapMaker.ExchangeTransactionHash,
                swap?.SwapMaker.ExchangeTransactionHex);
        }
    }

    //private async Task SellerExchangeFunds()
    //{
    //    ExtKey.UseBCForHMACSHA512 = true;
    //    NBitcoin.Crypto.Hashes.UseBCForHMACSHA512 = true;

    //    if (swap.SwapTaker.ReceiverPubkey != mypubkeyBuyerSide)
    //        throw new Exception("seller pubkey was changed");

    //    Networks.Network network = SwapsConfiguration.Networks[swap.SwapTaker.CoinSymbol];
      
    //    var account = _walletAccounts.GetAccount(swap.SwapMaker.CoinSymbol);
    //    var (errorOut, sharedSecret, sharedSecretHash) = await WalletService.GenerateSecretHash(account, swap.SwapSessionId);
    //    if (!string.IsNullOrEmpty(errorOut))
    //    {
    //        error = errorOut;
    //        return;
    //    }

    //    var extendedKey = ExtKey.Parse(storage.GetWalletPrivkey(), network);

    //    ExchangeSwapFund(swap.SwapTaker, sharedSecret, extendedKey.PrivateKey);

    //    await PostSwap(swap);

    //    await this.RefreshSwap();

    //    await this.BlockchainApiService.Broadcast(swap.SwapTaker.CoinSymbol, swap.SwapTaker.ExchangeTransactionHex);
    //}

    //private async Task BuyerExchangeFunds()
    //{
    //    ExtKey.UseBCForHMACSHA512 = true;
    //    NBitcoin.Crypto.Hashes.UseBCForHMACSHA512 = true;

    //    if (swap.SwapMaker.ReceiverPubkey != mypubkeySellerSide)
    //        throw new Exception("buyer pubkey was changed");

    //    if (string.IsNullOrEmpty(this.SharedSecret))
    //        throw new Exception("Missing shared secret");

    //    var walletWrods = storage.GetWalletWords();
    //    var extendedKey = HdOperations.GetExtendedKey(walletWrods);

    //    ExchangeSwapFund(swap.SwapMaker, new uint256(this.SharedSecret), extendedKey.PrivateKey);

    //    swap.Status = SwapsDataStatus.Complete;

    //    await PostSwap(swap);

    //    await this.RefreshSwap();

    //    await this.BlockchainApiService.Broadcast(swap.SwapMaker.CoinSymbol, swap.SwapMaker.ExchangeTransactionHex);
    //}

    //private void ExchangeSwapFund(SwapSessionCoin swapSessionCoin, uint256 sharedSecret, Key privateKey)
    //{
    //   Networks.Network network = SwapsConfiguration.Networks[swapSessionCoin.CoinSymbol];

    //    var transaciton = network.Consensus.ConsensusFactory.CreateTransaction(swapSessionCoin.SwapTransactionHex);
    //    var redeemScript = Script.FromHex(swapSessionCoin.SwapRedeemScriptHex);

    //    long fee = network.MinRelayTxFee * 3;

    //    PubKey pubKey = SwapsConfiguration.GetNextAvailableAddress(network, storage);

    //    var exchangeTransaction = SwapBuilder.CreateSwapSpendTransaction(
    //        network,
    //        transaciton,
    //        redeemScript,
    //        sharedSecret,
    //        pubKey.GetAddress(network).ScriptPubKey,
    //        privateKey,
    //        new FeeRate(new Money(fee)));

    //    swapSessionCoin.ExchangeTransactionHex = exchangeTransaction.ToHex(network.Consensus.ConsensusFactory);
    //    swapSessionCoin.ExchangeTransactionHash = exchangeTransaction.GetHash().ToString();
    //}

    private async Task SellerExchangeFunds1()
    {
        ExtKey.UseBCForHMACSHA512 = true;
        NBitcoin.Crypto.Hashes.UseBCForHMACSHA512 = true;

        if (swap.SwapTaker.ReceiverPubkey != mypubkeyBuyerSide)
            throw new Exception("seller pubkey was changed");

        Networks.Network network = SwapsConfiguration.Networks[swap.SwapTaker.CoinSymbol];

        var account = _walletAccounts.GetAccountByKey(swap.SwapMaker.SenderPubkey);
        var (errorOut, sharedSecret, sharedSecretHash) = await WalletService.GenerateSecretHash(account, swap.SwapSessionId);
        if (!string.IsNullOrEmpty(errorOut))
        {
            error = errorOut;
            return;
        }

        if (sharedSecretHash == null || sharedSecretHash.ToString() != swap.SharedSecretHash)
        {
            throw new Exception("Secret hash was not generated correctly");
        }

        var walletConnecet = new WalletConnectInput { WalletAccounts = _walletAccounts };
        var errorRes = await WalletService.ConnectWallet(walletConnecet);
        if (!string.IsNullOrEmpty(errorRes))
        {
            error = errorRes;
            return;
        }

        account = _walletAccounts.GetAccountByKey(swap.SwapTaker.ReceiverPubkey);

        var address = SwapsConfiguration.GetNextAvailableAddress1(walletConnecet, account);

        await ExchangeSwapFund1(swap.SwapTaker, sharedSecret, address, account);

        swap.Status = SwapsDataStatus.Complete;

        await PostSwap(swap);

        await this.RefreshSwap();

        await this.BlockchainApiService.Broadcast(swap.SwapTaker.CoinSymbol, swap.SwapTaker.ExchangeTransactionHex);
    }

    private async Task BuyerExchangeFunds1()
    {
        ExtKey.UseBCForHMACSHA512 = true;
        NBitcoin.Crypto.Hashes.UseBCForHMACSHA512 = true;

        if (swap.SwapMaker.ReceiverPubkey != mypubkeySellerSide)
            throw new Exception("buyer pubkey was changed");

        if (string.IsNullOrEmpty(this.SharedSecret))
            throw new Exception("Missing shared secret");

        Networks.Network network = SwapsConfiguration.Networks[swap.SwapMaker.CoinSymbol];

        var walletConnecet = new WalletConnectInput { WalletAccounts = _walletAccounts };
        var errorRes = await WalletService.ConnectWallet(walletConnecet);
        if (!string.IsNullOrEmpty(errorRes))
        {
            error = errorRes;
            return;
        }

        var account = _walletAccounts.GetAccountByKey(swap.SwapMaker.ReceiverPubkey);

        var address = SwapsConfiguration.GetNextAvailableAddress1(walletConnecet, account);

        await ExchangeSwapFund1(swap.SwapMaker, new uint256(this.SharedSecret), address, account);

        swap.Status = SwapsDataStatus.Complete;

        await PostSwap(swap);

        await this.RefreshSwap();

        await this.BlockchainApiService.Broadcast(swap.SwapMaker.CoinSymbol, swap.SwapMaker.ExchangeTransactionHex);
    }

    private async Task ExchangeSwapFund1(SwapSessionCoin swapSessionCoin, uint256 sharedSecret, string sendToAddress, WalletAccount account)
    {
        //if (mypubkeyBuyerSide != swapSessionCoin.ReceiverPubkey)
        //    throw new Exception("Invalid key");

        Networks.Network network = SwapsConfiguration.Networks[swapSessionCoin.CoinSymbol];

        var transaciton = network.Consensus.ConsensusFactory.CreateTransaction(swapSessionCoin.SwapTransactionHex);
        var redeemScript = Script.FromHex(swapSessionCoin.SwapRedeemScriptHex);

        var unsignedExchangeTransaction = SwapBuilder.CreateSwapSpendUnsignedTransaction(
            network,
            transaciton,
            sendToAddress,
            new Money(swapSessionCoin.NetworkFee));

        var swapCoinsInput = new BlockcoreWalletSwapCoins
        {
            walletId = account.WalletId,
            accountId = account.AccountId,
            network = network.CoinTicker,
            swapTrxHex = swapSessionCoin.SwapTransactionHex,
            redeemScriptHex = swapSessionCoin.SwapRedeemScriptHex,
            secretHashHex = Encoders.Hex.EncodeData(sharedSecret.ToBytes()),
            trxToSignHex = unsignedExchangeTransaction.ToHex(network.Consensus.ConsensusFactory),
            message = $"Swap {Money.Satoshis(swapSessionCoin.Amount)} {swapSessionCoin.CoinSymbol} to {sendToAddress}"
        };

        var result = await WalletService.SwapCoins(swapCoinsInput);

        if (result == null)
            throw new Exception("Failed to call SwapCoins api method on the wallet");

        if (string.IsNullOrEmpty(result.transactionId))
        {
            if (string.IsNullOrEmpty(result.privateKey))
                throw new Exception("Private key was not provided by wallet");

            var privkey = new Key(Encoders.Hex.DecodeData(result.privateKey));

            var exchangeTransaction = SwapBuilder.SignSwapSpendUnsignedTransaction(
                network,
                transaciton,
                unsignedExchangeTransaction,
                redeemScript,
                sharedSecret,
                privkey);

            swapSessionCoin.ExchangeTransactionHex = exchangeTransaction.ToHex(network.Consensus.ConsensusFactory);
            swapSessionCoin.ExchangeTransactionHash = exchangeTransaction.GetHash().ToString();
        }
        else
        {
            swapSessionCoin.ExchangeTransactionHex = result.transactionHex;
            swapSessionCoin.ExchangeTransactionHash = result.transactionId;
        }
    }

    private async Task ScanForSecretHash()
    {
        Networks.Network network = SwapsConfiguration.Networks[swap.SwapTaker.CoinSymbol];

        if (swap.SwapTaker.ExchangeTransactionHex != null)
        {
            var transaciton = network.Consensus.ConsensusFactory.CreateTransaction(swap.SwapTaker.ExchangeTransactionHex);

            var secret = SwapScripts.GetSecretFromScriptSig(transaciton);

            this.SharedSecret = secret.ToString();
            return;
        }

        var indexer = SwapsConfiguration.Indexers.First(f => f.Symbol == swap.SwapTaker.CoinSymbol);
        var url = $"/query/transaction/{swap.SwapTaker.SwapTransactionHash}";
        var res = await Http.GetFromJsonAsync<TransactionData>(indexer.Url + url);

        foreach (var output in res.outputs)
        {
            if (output.address == swap.SwapTaker.SwapAddress)
            {
                if (!string.IsNullOrEmpty(output.spentInTransaction))
                {
                    url = $"/query/transaction/{output.spentInTransaction}/hex";
                    var trxHex = await Http.GetStringAsync(indexer.Url + url);

                    if (res != null)
                    {
                        swap.SwapTaker.ExchangeTransactionHex = trxHex; // the other side didn't tell us they spent the coins

                        var exchangeTransaciton = network.Consensus.ConsensusFactory.CreateTransaction(trxHex);

                        var secret = SwapScripts.GetSecretFromScriptSig(exchangeTransaciton);

                        this.SharedSecret = secret.ToString();
                    }
                }
            }
        }
    }

    //private async Task SellerRecoverFunds()
    //{
    //    ExtKey.UseBCForHMACSHA512 = true;
    //    NBitcoin.Crypto.Hashes.UseBCForHMACSHA512 = true;

    //    if (swap.SwapMaker.SenderPubkey != mypubkeySellerSide)
    //        throw new Exception("buyer pubkey was changed");

    //    var walletWrods = storage.GetWalletWords();
    //    var extendedKey = HdOperations.GetExtendedKey(walletWrods);

    //    RecoverFunds(swap.SwapMaker, extendedKey.PrivateKey);

    //    await PostSwap(swap);

    //    await this.RefreshSwap();

    //    await this.BlockchainApiService.Broadcast(swap.SwapMaker.CoinSymbol, swap.SwapMaker.RecoveryTransactionHex);
    //}

    //private async Task BuyerRecoverFunds()
    //{
    //    ExtKey.UseBCForHMACSHA512 = true;
    //    NBitcoin.Crypto.Hashes.UseBCForHMACSHA512 = true;

    //    if (swap.SwapTaker.SenderPubkey != mypubkeyBuyerSide)
    //        throw new Exception("buyer pubkey was changed");

    //    var walletWrods = storage.GetWalletWords();
    //    var extendedKey = HdOperations.GetExtendedKey(walletWrods);

    //    RecoverFunds(swap.SwapTaker, extendedKey.PrivateKey);

    //    await PostSwap(swap);

    //    await this.RefreshSwap();

    //    await this.BlockchainApiService.Broadcast(swap.SwapTaker.CoinSymbol, swap.SwapTaker.RecoveryTransactionHex);
    //}

    //private void RecoverFunds(SwapSessionCoin swapSessionCoin, Key privateKey)
    //{
    //    //if (mypubkey != swapSessionCoin.SenderPubkey)
    //    //    throw new Exception("Invalid key");

    //    Networks.Network network = SwapsConfiguration.Networks[swapSessionCoin.CoinSymbol];

    //    var transaciton = network.Consensus.ConsensusFactory.CreateTransaction(swapSessionCoin.SwapTransactionHex);
    //    var redeemScript = Script.FromHex(swapSessionCoin.SwapRedeemScriptHex);

    //    long fee = network.MinRelayTxFee * 3;

    //    PubKey pubKey = SwapsConfiguration.GetNextAvailableAddress(network, storage);

    //    var recoveryTransaction = SwapBuilder.CreateSwapRecoveryTransaction(
    //        network,
    //        transaciton,
    //        redeemScript,
    //        pubKey.GetAddress(network).ScriptPubKey,
    //        privateKey,
    //        new FeeRate(new Money(fee)),
    //        swapSessionCoin.RecoveryLockTime!.Value);

    //    swapSessionCoin.RecoveryTransactionHex = recoveryTransaction.ToHex(network.Consensus.ConsensusFactory);
    //    swapSessionCoin.RecoveryTransactionHash = recoveryTransaction.GetHash().ToString();
    //}

    private async Task SellerRecoverFunds1()
    {
        ExtKey.UseBCForHMACSHA512 = true;
        NBitcoin.Crypto.Hashes.UseBCForHMACSHA512 = true;

        if (swap.SwapMaker.SenderPubkey != mypubkeySellerSide)
            throw new Exception("seller pubkey was changed");

        Networks.Network network = SwapsConfiguration.Networks[swap.SwapMaker.CoinSymbol];

        var walletConnecet = new WalletConnectInput { WalletAccounts = _walletAccounts };
        var errorRes = await WalletService.ConnectWallet(walletConnecet);
        if (!string.IsNullOrEmpty(errorRes))
        {
            error = errorRes;
            return;
        }

        var account = _walletAccounts.GetAccountByKey(swap.SwapMaker.SenderPubkey);

        var address = SwapsConfiguration.GetNextAvailableAddress1(walletConnecet, account);

        await RecoverFunds1(swap.SwapMaker, address, account);

        swap.Status = SwapsDataStatus.Complete;

        await PostSwap(swap);

        await this.RefreshSwap();

        await this.BlockchainApiService.Broadcast(swap.SwapMaker.CoinSymbol, swap.SwapMaker.RecoveryTransactionHex);
    }

    private async Task BuyerRecoverFunds1()
    {
        ExtKey.UseBCForHMACSHA512 = true;
        NBitcoin.Crypto.Hashes.UseBCForHMACSHA512 = true;

        if (swap.SwapTaker.SenderPubkey != mypubkeyBuyerSide)
            throw new Exception("buyer pubkey was changed");

        Networks.Network network = SwapsConfiguration.Networks[swap.SwapTaker.CoinSymbol];

        var walletConnecet = new WalletConnectInput { WalletAccounts = _walletAccounts };
        var errorRes = await WalletService.ConnectWallet(walletConnecet);
        if (!string.IsNullOrEmpty(errorRes))
        {
            error = errorRes;
            return;
        }

        var account = _walletAccounts.GetAccountByKey(swap.SwapTaker.SenderPubkey);

        var address = SwapsConfiguration.GetNextAvailableAddress1(walletConnecet, account);

        await RecoverFunds1(swap.SwapTaker, address, account);

        swap.Status = SwapsDataStatus.Complete;

        await PostSwap(swap);

        await this.RefreshSwap();

        await this.BlockchainApiService.Broadcast(swap.SwapTaker.CoinSymbol, swap.SwapTaker.RecoveryTransactionHex);
    }

    private async Task RecoverFunds1(SwapSessionCoin swapSessionCoin, string sendToAddress, WalletAccount account)
    {
        //if (mypubkey != swapSessionCoin.SenderPubkey)
        //    throw new Exception("Invalid key");

        Networks.Network network = SwapsConfiguration.Networks[swapSessionCoin.CoinSymbol];

        var transaciton = network.Consensus.ConsensusFactory.CreateTransaction(swapSessionCoin.SwapTransactionHex);
        var redeemScript = Script.FromHex(swapSessionCoin.SwapRedeemScriptHex);

        var unsignedRecoverTransaction = SwapBuilder.CreateSwapRecoveryUnsignedTransaction(
            network,
            transaciton,
            sendToAddress,
            new Money(swapSessionCoin.NetworkFee),
            swapSessionCoin.RecoveryLockTime!.Value);

        var swapCoinsInput = new BlockcoreWalletSwapCoins
        {
            walletId = account.WalletId,
            accountId = account.AccountId,
            network = network.CoinTicker,
            swapTrxHex = swapSessionCoin.SwapTransactionHex,
            redeemScriptHex = swapSessionCoin.SwapRedeemScriptHex,
            secretHashHex = null, // this means it is recover not swap
            trxToSignHex = unsignedRecoverTransaction.ToHex(network.Consensus.ConsensusFactory),
            message = $"Recover {Money.Satoshis(swapSessionCoin.Amount)} {swapSessionCoin.CoinSymbol} to {sendToAddress}"
        };

        var result = await WalletService.SwapCoins(swapCoinsInput);

        if (result == null)
            throw new Exception("Failed to call SwapCoins api method on the wallet");

        if (string.IsNullOrEmpty(result.transactionId))
        {
            if (string.IsNullOrEmpty(result.privateKey))
                throw new Exception("Private key was not provided by wallet");

            var privkey = new Key(Encoders.Hex.DecodeData(result.privateKey));

            var recoveryTransaction = SwapBuilder.SignSwapRecoveryUnsignedTransaction(
                network,
                transaciton,
                unsignedRecoverTransaction,
                redeemScript,
                privkey);

            swapSessionCoin.RecoveryTransactionHex = recoveryTransaction.ToHex(network.Consensus.ConsensusFactory);
            swapSessionCoin.RecoveryTransactionHash = recoveryTransaction.GetHash().ToString();
        }
        else
        {
            swapSessionCoin.RecoveryTransactionHex = result.transactionHex;
            swapSessionCoin.RecoveryTransactionHash = result.transactionId;
        }
    }
}
